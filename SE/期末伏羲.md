### Ch.1 the nature of software

####  软件的定义：

软件是一组组成配置的项目或对象，包括：

* instructions（指令/computer programs），执行时提供所需功能和性能的指令
* data structure，使程序能充分操作信息的数据结构
* documents（操作手册）：描述程序的操作和使用

#### 软件与一般制造不同

Software doesn’t wear out,but it does deteriorate

软件是发展的开发的以及工程的，与一般的制造不同

![image-20210617000827395](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617000827395.png)

###### *说明：蓝色的是硬件的曲线，青色为软件的理想曲线，红色为软件的真实曲线（虽然软件不会磨损但会退化）软件破损曲线呈现“U”型，并且软件基于模块的组装【趋向于costom build定制】*



####  软件类型：

* 软件系统 system software，

  * 整套服务于其他程序的程序，分为编译器类的（处理复杂但确定的信息结构）和操作系统类的（处理不确定的数据）

* 应用软件application software，

  * 解决特定业务的独立应用程序

* 工程化/科学软件 engineer /scientific software【如红外隐身】，

  * “数值”计算类程序

* embedded software嵌入系统，

  * 存在于某个产品或系统中，执行有限和内部的功能或提供控制能力以及重要功能

* product-line software，与产品线相关的软件

  * 为多个不同用户的使用提供特定功能，关注有限的及内部的市场或大众消费市场

* web-applications，web应用

* AI（artificial intelligence software）人工智能软件

  * 利用非数值算法解决计算和直接分析无法解决的问题【如机器人，专家系统，模式识别】
  
  

####  遗留软件【Legacy software】为什么必须改变：

* 变更adapted，以满足新的计算环境或技术需求
* 增强enhanced，实现新的业务需求
* extended扩展，使其能和其他更加现代的系统或数据库进行互操作
* re-architect重新构架，适用于新构架，在网络环境中可实施。

  



###### 软件上的“神话”【Myths】

* 对于管理
  * 通过一本书来使人们知道软件构建的所有事情，但实际上没人在乎这样做
  * 如果工程来不及，可以增加更多的程序员完成，事实上相反
  * 通过外包的方式，就可以不管

​         

* 对于消费者
  * 一个目标就可以开始写程序，后期细节可以慢慢添加
  * 项目需求不断变化，由于软件灵活，变化很容易得到适应



![image-20210617000800119](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617000800119.png)

* practitioners（从业者）
  * 一旦编写一个程序并让它开始工作，我们的工作就完成了，事实上，你越早开始写，过程越长
  * 程序运行之前，无法评估它的质量；但实际上，正式的技术评估是一种质量过滤器
  * 一个成功的项目，唯一可交付的是程序；实际上程序只是软件配置的一部分，像文档是开发的基础
  * 软件工程会产生大量和不必要的文档，会放慢速度；但实际上软件设计和创建文档无关，是与质量有关的，质量好的会有较少返工



### Ch.2 software engineering

软件工程：将系统化的，规范的，可量化的方法应用于软件的开发，运行和维护【但系统化的，规范的，可量化对团队来说可能是负担，所以在规范外还要适应性和灵活】

#### software engineering is a layer technique【层次结构】

* 质量关注点【支持软件工程的根基】--》

* 过程模式【帮助创建及时的高质量的路线图】【使得各个技术层次结合一起，定义了一个框架，是软件项目管理的基础】--》

* 方法【提供软件如何构建的技术支持，提供技术上的解决方法，包括沟通，需求分析，设计建模等】--》

* 工具【计算机辅助的软件工程设计，为过程和方法提供自动化或半自动化支持。工具可以集成或一个工具产生的信息会被另一个工具使用】

  <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001002512.png" alt="image-20210617001002512" style="zoom: 33%;" />

#### 5 Process Framework

* Communication【客户协作（理解利益相关者的目标）与需求收集，方便定义软件特性和功能】
* Planning【建立工程工作计划，描述技术风险，列出资源需求，生产的产品，并定义工作计划】
* Modeling【建模，包括体系结构和不同构件如何组合，帮助开发者与用户了解需求和软件设计】
* Construction【构建，代码与测试，对所作的设计进行构建】
* deployment【全部或部分增量后，用户评价与反馈的意见】



#### 7 General Principle

* keep it simple，stupid（KISS）

  * 保持简洁。简洁但不过于简化，利于理解和维护

* provide value to users 

  * 存在价值。一个软件因为能给用户提供价值而有价值，这天原则是其他原则的基础

* maintain the vision （愿景）

  * 保持愿景。这是成功的基础，是概念的一致性，否则会破坏设计

* what you produce,other will consume生产的即能用的

  * 关注使用者。来需求说明，设计和实现过程中，要让别人理解系统

* ##### open to future

  * 面向未来的。生命周期长的系统有更高的价值，所以系统应该要适应多种变化

* plan ahead for reuse 

  * 提前计划复用。为了达到面向对象程序设计所能提供的复用性，需要有前瞻性的设计和计划

* think

  * 真正思考。在行动前要清晰定位，完整思考一般能达到较好的结果



### Ch.3 Software Process Structure

#### 4 Process flow

过程流：描述了在执行顺序上和执行时间上如何组织框架中的活动，动作，任务

##### ①linear process flow

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001143812.png" alt="image-20210617001143812" style="zoom:50%;" />

##### ②iteration process flow

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001151490.png" alt="image-20210617001151490" style="zoom:50%;" />

##### ③evolutionary process flow（演化流）

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001158708.png" alt="image-20210617001158708" style="zoom:50%;" />

##### ④parallel process flow（并行流）

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001204895.png" alt="image-20210617001204895" style="zoom:50%;" />



#### Process Patterns

描述了软件工程工作中遇到的过程相关的问题。明确了问题环境并给出针对问题的多种解决方案

###### 定义为工作产品构建过程中所需完成的工作活动，动作和任务的集合

<img src="C:\Users\all\AppData\Roaming\Typora\typora-user-images\image-20210619210546196.png" alt="image-20210619210546196" style="zoom:33%;" />

* 一个模板【在软件过程的背景下统一描述问题解决方案的方法】用于定义一种模式。

* 通用的软件模式元素包括：
  * meaningful pattern name 【能描述模式在软件工程中的意义】
  * intent【意义，驱动力】 
  * 类型【包括】
    * task pattern（定义任务，定义了与软件工程动作或工作任务相关的问题，如收集需求） 【重视目的】
    * stage pattern（步骤模式，定义了与框架活动有关活动的相关问题，如communication作为一个步骤模式可能包括需求收集等任务） 【重视途径】
    * phase pattern（阶段模式，定义了在过程中发生的框架活动序列，迭代的，如螺旋模型和原型开发）
  * 启动条件【描述模式应用的前提】
  * 问题
  * 解决方案
  * 结果
  * 相关模式
  * 已知应用和实例



#### Process Assessment 过程评估

![image-20210617001301370](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001301370.png)



#### CMMI【Capability Maturity Model Integration】

* 能力成熟度模型集成

* by Software Engineering Institute (SEI) of Carnegie Mellon University (CMU) 

* 6个等级

  * **Level 0: Incomplete** 

    * 进程未执行或未实现为此级别定义的所有目标

    

  * **Level 1: Performed**
    * 正在执行生产所需工作产品所需的工作任务
  * **Level 2: Managed**
    * 从事工作的人可以获得足够的资源来完成工作，利益相关者会积极参与，工作任务和产品会被监控、审查和评估是否符合流程描述
  * **Level 3: Defined**
    * 管理和将记录的，标准化的，集成的过程弄到全组织范围的工程过程中
  * **Level 4: Quantitatively Managed**
    
    * 使用详细的措施定量理解和控制软件过程和产品
  * **Level 5: Optimizing**最优化设计
    
    * 通过流程的定量反馈和测试创新想法实现持续改进
  
  



### Ch.4 Process Models

过程模型为软件工程工作提供了特定的路线图，规定所有活动的流程，动作，任务，迭代程度，工作产品以及要完成的工作如何组织

#### Prescriptive model惯例模型：

##### ①The water model

* communication-- planning --modeling-- construction-- deployment

* 缺点：真正项目没有按照这个方式来，有时候用户可能会修改需求（需求不明确），工期不确定可能延长

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001352379.png" alt="image-20210617001352379" style="zoom: 33%;" />

##### ②The increment model（增量模式）：

* 先完成最核心的功能，20%的时间完成80%的功能，但比较繁琐

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001508011.png" alt="image-20210617001508011" style="zoom: 33%;" />

* RAD模型

  * The R（Rapid）A（Application）D（development） model：资源需求多（人要多），需要承诺（开发者与用户需要急速的进行），系统可能缺乏模块化（如果系统不能正确的模块化，可能无法工作），可能没法对接，如果技术含量比较高就不适合



#### Evolutionary process models【进化过程模型】

①Prototyping（原型）

* 有说服力，有原型的，有迭代的，可以较快开始

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001543835.png" alt="image-20210617001543835" style="zoom:50%;" />



②Concurrent development model【协同发展模型】

* 将传统的步骤打乱，灵活，但质量可能无法保证（一定要注重测试）
* 特点：定义了一个活动网络，而不是线性的事件序列；对于客户端和服务器应用程序比较友好；定义为每个活动，操作，或任务触发状态转换的事件

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001641743.png" alt="image-20210617001641743" style="zoom:50%;" />





#### *Specialized process model【专用过程模型】*

##### 特点

* component-based development model

  * 基于组件开发的模型【当可重复利用的部分是可以用到这个程序中的时候】

  * 具有许多螺旋模型的特点，本质上是演化模型，但不同的是，其使用预先打包好的软件构建来开发

* formal methods model

  * 形式化的方式模型，使开发者用严格的数学符号表示，开发和验证基于计算机的系统】
  * 可以提供无缺陷的软件，但耗时，成本高，对于技术不高的客户，沟通较困难

* Aspect-Oriented Software Development（AOSD）面向方面的软件开发

  * 【提供了定义，指定，设计和构建方面的过程和方法，对于横切关注点（涉及多个方面功能，特性或信息的关注点）进行局部表示的一种机制】
  * 具有演化模型【适合定义和构建】和并行模型的共同特点



#### The unified process统一过程

* A “**use-case** driven, **architecture**-centric, **iterative** and 

  **incremental**” software process closely aligned with the **U**nified 

  **M**odeling **L**anguage (**UML**)【用例驱动，以体系结构为中心，迭代的，增量的，和UML图是紧密的】

  <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617001721103.png" alt="image-20210617001721103" style="zoom:33%;" />
  
  * 起始阶段【inception phase】
    * 客户沟通和策划活动。得到业务需求，提出大致体系结构，并制定开发计划
    * 识别基本的业务需求，初步用用例描述每一类用户的主特性和功能
  * 细化阶段【elabortion phase】
    * 沟通和通用过程建模。评审项目计划来确保项目的范围，风险和交付日期合理性。主要是对项目计划进行修订
  * 构建阶段【construction phase】
    * 构建活动。采用体系结构作为输入，开发或获取软件构件，使得用户能操作用例。
    * 对细化阶段的需求和设计模型加以完善，以反映软件增量的最终版本
  * 转换阶段【transition phase】
    * 构建活动后期以及通用部署活第一部分。
    * 软件进行β测试，用户反馈缺陷以及必要变更，该阶段后，软件增量可以称为可发布版本
  * 生产阶段【production phase】
    * 与通用部署活动一样，持续使用软件进行监视，提供运行环境的支持，提交并评估缺陷和变更请求

#### *Personal and Team Process Models【少对比】*

##### personal software process model【对于工程师应该较早认识到错误并认识各种错误】PSP

* 建议流程

  * Planning

  * High-level design

  * High-level design review

  * Development

  * Postmortem (**后验**) 

    强调每个软件工程师需要尽早识别错误，以了解错误的类型

##### **Team Software Process (TSP)**

* 每个项目要按照定义来完成任务的“脚本”，“启动”

* 团队是自我领导的

* 注重测试

* 采取一些策略来改进团队流程





### Ch.5 Agile Development

#### agility

* **Effective** response to **change/communication;** 
  * 对变化的有效（快速并且自适应）响应
* Driven by customer’s requirement; 
  * 由用户需求驱动
* Self-**organization/control**; 
  * 组织一个团队，以便控制所执行的工作
* Rapid, incremental delivery of software
  * 快速的增量地提交软件

#### 12 Agility Principle

<u>团队方面</u>

* 业务与开发者必须每天一起工作
* 围绕着有动机的个人来进行项目，提供环境与支持，相信他们能完成任务
* 面对面对话是向开发团队内部传达信息的最有效方式
* 团队定期反思如何更有效，并作出调整

<u>快速增量地提交</u>	

* 在更短的时间内，经常提供可工作的软件
* 可工作的软件是衡量过程的主要标准
* 首要任务是提前和持续交付有价值的软件

<u>对变化响应快</u>

* 敏捷开发促进了可持续发展
* 持续关注卓越的技术水平和良好的设计，提高灵活度
* 简单--最大化不用完成的量
* 选择最佳的体系结构，需求以及设计

<u>用户需求驱动</u>

* 欢迎不断变化的需求【即使在开发后期】，敏捷流程利用变革来实现客户的竞争优势



#### XP【大型组织内部使用】

**Extreme Programming(XP，最广泛使用的敏捷开发，Kent Beck提出)**

* XP Planning

  * 从创建用户故事开始
  * 敏捷团队评估每个故事并分配成本
  * 将故事分组，以便获得可交付成果的增量
  * 给出关于交付时间的承诺
  * 在第一个增量之后，使用“项目速度”帮助定义其他增量的交货日期【项目速度：第一个发行版本中实现地客户故事个数；用于评判发布日期与安排以及是否过分承诺】

* XP Design

  * 遵循KIS（keep it simple原则）
  * 使用CRC卡
  * 对于困难的设计问题，建议创建spike解决方案【一个设计原型，真正实现地时候就降低风险，对可能有问题的故事确认】
  * 鼓励“重构”【对于内部程序进行迭代细化】

* XP Coding【不是直接开始编码】

  * 建议在编码开始之前为存储区域进行单元测试，只要完成单元测试就好了
  * 鼓励“配对编程”【pairing programming】【两个人面对同一台计算机，共同为同意故事开发】
    * 提供实时解决问题【两个人一般比一个人强】
    * 实时的质量保障机制
    * 两人的任务可能不同

* XP Testing

  * 每天都要执行所有的单元测试
  * “验收测试”由客户定义并执行，以评估可见功能

  ![image-20210604203544477](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210604203544477.png)



#### Agile Process Models

①ASD (Adaptive Software Development);

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619220441631.png" alt="image-20210619220441631" style="zoom:67%;" />

* speculation【思考】
  * 自适应周期计划
  * 任务声明
  * 项目限制
  * 基本要求
  * 时间箱发布计划
* collaboration【协作】
  * 将需求联合起来
  * 应用程序开发
  * 小规格的开发？
* learning【学习】
  * 组件实施/测试的焦点小组反馈
  * 正式技术审查事后调查结果

**②DSDM** ( Dynamic Systems Development Method); 

* 由DSDM联盟推广【和XP很像，有九个指导原则】

* 符合 Pareto principl：20%的时间完成80%的功能

* 必须主动进行用户参与（必要的）。必须授权DSDM团队（授权）做出决策。重点是产品的频繁交付。适合于商业目的是接受可交付成果的基本标准。迭代和增量开发对于（聚集）收敛在一个精确的业务解决方案上是必要的。开发过程中的所有更改都是可逆的（可逆的）。要求在整个生命周期中集成了高级测试

* 迭代周期

  * 功能模型迭代
    * 为客户开发一系列可证明其功能的增量原型。
    * 意图：在用户使用原型系统时应道出反馈信息来补充需求
  * 设计和构建迭代
    * 在功能迭代中，要重新构建原型，一般功能，设计，构建迭代可以同步进行
  * 实现
    * 将软件增量【可操作的原型】放在运行环境中【由于增量不一定全部完成，并且运行环境可能变化，所以又到功能迭代阶段】
  
  ![image-20210604203723926](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210604203723926.png)
  
  

**③Scrum**: 15 min daily meeting (3 **questions)** 

过程由需求，分析，设计，演化，交付构成，发生于一个过程模式中的工作任务为冲刺

特点

* 开发工作分为“包”（打包）
* 随着产品构建进行测试和文档（不间断地）
* 工作发生在“冲刺”（冲刺）中，源自现有需求的“积压”（待定项）
  * 冲刺由一些工作单元组成。必须在预定的时间段内完成
  * 冲刺过程不能变更，所以短期但稳定
* 会议非常短，有时不主持
* “演示”【向客户交付增量】通过分配的时间框（时间段）交付给客户

![image-20210605150636921](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210605150636921.png)

④Crystal

* 水晶方法。与XP一样以人为中心，但没有Xp的高纪律性，效率可能没那么高，但更容易遵循
* 通过人数来划分不同的水晶方法等级，同时提出错误引发后果的等级

⑤FDD ( Feature Driven Development)

* 强调特性驱动，快速迭代，同时保证了文档和质量
* 每个功能开发不超过2周，给每个用例都限定了粒度
* 打破了传统的将领域和业务专家 / 分析师与设计者和实现者隔离开来的壁垒。分析师被从抽象的工作中解脱出来，直接参与到开发人员和用户所从事的系统构造工作中。





#### AM(Agile Modeling)

* Scott Ambler提出，是一种基于实践的方法学
* 对基于软件的系统有效建模和文档编制
* 特点
  * 由计划来建模，有目的的模型
    * 建模前，开发者应该有明确的目标
  * 用多个模型
  * 轻装上阵---学会舍弃
    * 只保留长期有效的模型
  * 内容比表示更重要
    * 应该向读者分享重要信息。语法完美但有用信息少的模型也是不好的
  * 了解建模的模型与相应工具【包括优缺点】
  * 本地适应【适应团队的要求】
* 现在一般用UML【统一建模语言】来表示分析和设计模型





### Ch.6 Human Aspects of Software Engineering

#### Traits of Successful Software Engineers

* 个人责任感

* 对一些人的需求有敏锐的意识

* 坦诚的（指出有问题的设计）

* 抗压能力

* 高度的公平感（避免利益冲突，不破坏他人劳动成果）

* 注重细节（利用产品已有的概括性标准在日常工作基础上仔细思考，进而做出技术性决策）

* 务实

  

#### The Psychology of SE

* Bill Curtis和Diane Walz提出分层的行为模型

 <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617000556788.png" alt="image-20210617000556788" style="zoom:50%;" />

①在个人层面，软件工程心理学注重待解决的问题，解决问题需要的技能，以及解决问题的动机（在模型外层建立的限制内）

②在团队和项目层面，团队能动性为主要因素，成功是由团队结构和社会因素决定的。

③结合①②可得，团队交流和个体技能等同重要。

④在外部层面，有组织的行为控制着公司行为和对商业环境的应对方式

个人包括：

* 外联员ambassador：和外部顾客进行谈判，并得到利益相关者的反馈
* 侦察员scout：收集组织信息（外部市场，新技术，外界相关活动，潜在对手的活动）
* 守护员guard：保护团队工作产品和其他信息产品
* 安检员sentry：把控利益相关者和他人向团队传送的消息
* 协调员coordinator：注重跨团队以及组织内部的交流

#### Effective Software Team Attributes 有效软件团队的属性

* 目的感 purpose
* 参与感 involvement
* 信任感 trust
* 进步感（（定期审视软工方法并找改善））improvement
* 团队成员技能的多样性（多元性）Diversity of team member skill sets

#### **The Software** **Team / Agile Teams**

* 强调**个人能力**和**团队协作**作为关键成功因素
* 人比过程重要，而politics【政治？】比人重要
* 敏捷团队是自组织的，有很多结构
  * 一个自适应的团队结构
  * 使用Constantine的random，open，synchronous的结构
  * 显著的自主性
* 计划保持在最低限度，并且仅受业务要求和组织标准的限制【比如scrum中的每日会议】



#### SE **using the Cloud**

* 好处
  * 提供对所有软件工程产品的访问
  * 删除设备依赖性
  * 团队进行独立于平台，低风险的新型软件实验，得到反馈
  * 提供用于发布和测试软件的途径
  * 允许一个成员的信息提供给其他人
  * 沟通方便【管理，进度安排，任务列表，需求和缺陷管理这些功能可进行自我调整】
  * 影响软件工程师组织团队的方式，工作的方法，交流和连接的方式，管理项目的方式。
* 缺陷
  * 分布在多个服务器，不受软件团队的控制
  * 可靠性与安全性问题，【云强调可用性与性能这个和安全性，可靠性等冲突】
  * 由于云上分布大量服务，互操作性问题可能性很高





#### **Collaboration** **Tools**【协作工具】

* 软件开发环境SDE--》协作开发环境CDE【collaboration development environment】

* 功能：实现简易化，自动化，对整个开发过程控制
* 有价值的CDE会提供一系列服务
  * 命名空间（可选择性访问,允许安全，私有存储或工作产品的命名空间）
    * 加强安全性和保密性
  * 进度表（协调会议，事件）
  * 模板（保持一致的外形和结构）
  * 度量支持（量化成员的贡献）
  * 交流分析会（跟踪整个团队的交流并分离出模式）
  * 工件收集，项目（加工品）集群显示工作产品依赖性【如github】

#### **Global Teams**（GSD）全球软件开发

* 影响因素

  * 问题复杂度

  * 结果不确定（工作相关的决策会对另外的项目产生意外的影响）

  * 对问题的不同看法才是导致不同结论的关键

  * 与决策相关的不确定性和风险

    ![image-20210606142042723](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210606142042723.png)

    * *communication*
    * *collaboration*
    * *coordination*
    * *principles that guide practice*

    

### *Ch.7 Principles that Guide Practice*

* 软件工程原理可能为专业程序员的整个职业生涯服务【东西太多】

#### software engineering knowledge

* 你经常听到人们说软件开发知识有3年的半衰期：你今天需要知道的知识有一半将在3年内被淘汰（废弃的，过时的）。在与技术相关的知识领域，这可能是正确的。但还有另一种软件开发知识——我认为这是“软件工程原则”——没有三年的半衰期。这些软件工程原理可能为专业程序员的职业生涯服务

#### **Communication** **Principles** 

* listen。尽量关注演讲者的词，而不是表达你对这些词的反应
* prepare before you communicate。
* someone should facilitate the activity
  * 每个沟通会议都应该有一个领导者(一个促进者)来保持对话朝着一个有效的方向进行；
  * 调解任何发生的冲突
  * 确保遵循其他原则
* face-to-face communication is best
* take notes and document decisions。参与沟通的人应该充当“记录器”，写下所有重要的要点和决定。
* strive for collaboration。当团队成员的集体知识相结合时，就会出现协作与共识（一致、合意
* stay focused，modularize【模块化】 your discussion。参与任何交流的人越多，讨论就越有可能从一个话题反弹到另一个话题
* if something is unclear，draw a picture
* (a) Once you agree to something, move on; (b) If you *can’t agree* *to* *something,* move on; (c) If a feature or function is unclear and cannot be clarified at the moment, move on
* *Negotiation*【谈判】 *is not a contest or a game. It works best when both* parties win.



Agile modeling principles

* The primary goal of the software team is to build software not create models.【团队要构建软件而不是模型】

* Travel light – don’t create more models than you need.【不要创建太多模型】

* Strive to produce the simplest model that will describe the problem or the software.【用最简单的模型】

* Build models in a way that makes them amenable to change.【用一种易于更改的方式构建模型】

* Be able to state an explicit purpose for each model that is created.【能够为创建的每个模型的明确目的。】

* Adapt the models you create to the system at hand. 【将您创建的模型调整到手头的系统中】

* Try to build useful models, forget about building perfect models. 【试着建立有用的模型，忘记建立完美的模型】

* Don’t become dogmatic about model syntax. Successful communication is key.【不要对模型语法产生教条主义的影响。成功的沟通是关键】

* If your instincts tell you a paper model isn’t right you  may have a reason to be concerned.【如果你的直觉告诉你一个纸模型不对，你可能有理由担心】

* Get feedback as soon as you can.【尽快获得反馈】

  

  

### Ch.8 Understanding Requirements

#### 8 requirements Engineering task

①Inception（stakeholders) 开始

* 建立基本的理解（存在的问题，这是谁的需求（明确共同利益者）

* 解决问题的人

* 解决方案的性质

* 与利益相关者和开发人员之间初步交流效果），粗略的可行性分析【在确定了商业需求之后才开始】

* **<u>启动需求工程的步骤</u>**

  * 确定利益相关者【直接/间接从正在开发地系统中获利的人】，在开始阶段，需求工程师应该创建一个人员列表，得到有利于获取需求的人员

  * 识别多重观点：不同利益相关者有着不同视角，分类后形成内部一致的集合

  * 协同合作：识别公共和矛盾区域，并进行删减

  * 首次提问：识别利益相关者，更好的理解问题，关注沟通活动本身的效率【QA会议一般用于首次接触】

    * 工作的负责人，谁将使用解决方案，方案的经济效益是什么，是否需要其他解决方案的来源

  

②Elicitation 【许可？获取】

![image-20210607162151232](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210607162151232.png)

QFD：质量功能部署，将用户需求转化成质量需求

* 三类需求
  * Normal requirements【任务书中明确指出的要求】
  * Expected requirements【任务书中没有，但是是用户隐含需要的】
  * Exciting requirements【任务书中没有，同时用户也是想不到的】
* Non-Functional Requirements非功能性需求
  * 包括
    * 质量属性 **quality** **attribute**
    * 性能属性 **performance** 
    * 安全属性 **security** **attribute**
    * 一般性的系统约束 **general system** **constraint**
  * 如何确定哪些NFR可以兼容？
    * 第一阶段是，将每个NFR作为列元素，以system SE guidelines作为行元素的矩阵
    * 第二阶段是，使用一组决策规则对每个NFR进行优先级排行，通过将每个NFR和guidelines互补，重叠，冲突，独立来决定实现哪个
* Use cases【用例】
  * 描述系统使用线程的用户场景的集合
  * 每个场景都从一个“参与者”的角度来描述——一个以某种方式与软件交互的人或设备
  * 每个场景都回答以下问题：-谁是主要参与者、次要参与者？-该演员的目标是什么？-在故事开始前应该存在什么先决条件？-参与者要执行哪些主要任务或功能？

③ **Elaboration** （ building analysis model **）**

* 细化【建立一个可识别数据，功能和行为需求的分析模型】
* 核心是开发一个精确的需求模型，用于说明软件的功能，特征，信息。由用户场景建模和求精任务驱动。应该定义每个分析类的属性，确定每个类所需的服务，确定类之间的关联和协作关系，并完成各种补充

④ Negotiation 

* 协商【开发者和客户来现实的可交付系统达成一致】
* 业务资源和过高要求的矛盾/客户与用户之间需求矛盾，使用迭代的方式给需求排序，评估每项需求的成本和风险，处理内部冲突，删除、组合或修改需求
* 协商流程
  * 确定主要利益相关者
  * 确定各利益相关者的利益点
  * 进行协商

⑤Monitoring

* 监控【需求检测：特别在增量开发比较重要】

* 类型

  * distributed debugging 分布式调试（发现错误并确定原因）

  * run-time verification运行时验证 确定软件是否符合规范

  * run-time validation运行时确认 评估演进中的软件是否满足用户目标

  * business activity monitoring 业务活动监控 评估系统是否满足业务目标

  * evolution and co-design进化与协同设计 随着系统的发展而向利益相关者提供信息

    

⑥Specification 

* 规格说明
* 对于不同的人等含义不同，可包含以下一至多项

  * 文档
  * 图形化模型
  * 数学模型
  * 使用场景
  * 一个原型或上面的组合【大型系统，一般用语言和图形模型；小型的用使用场景】

⑦Validation(**Consistency / Omissions / Ambiguity**) 

* consistency
  * 每个要求是否与系统或产品的总体目标一致
* omissions
  * 遗漏项
  * 是否在适当的抽象级别上规定了所有要求（某些要求是否提供了本阶段不合适的技术细节）
* ambiguity
  * 模糊性

⑧Requirements management**（**changes)

* （需求管理）：帮助项目组在项目展开中标识，控制和跟踪需求以及需求变更地一组活动



#### Use-Case Diagram

![image-20210607184609526](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210607184609526.png)



#### class Diagram 类图

![image-20210607185525357](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210607185525357.png)



#### Activity Diagram

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210607210019184.png" alt="image-20210607210019184" style="zoom:80%;" />



#### State Diagram

![image-20210618210522814](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210618210522814.png)





### Ch.9 Requirements Modeling：Scenario-Based Methods 基于场景

#### 4 requirements models

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617002208767.png" alt="image-20210617002208767" style="zoom:50%;" />

#### Scenario-Based modeling

* use-case：actors and users
  * 描述系统参与者的使用流程
  * 参与者的代表人物或设备
  * 用户可以为给定的场景扮演不同的角色

* Developing  a Use-Case

  * 参与者执行的主要人物或功能是什么
  * 操作者将获取，生成或更改哪些系统信息
  * 参与者是否必须告知系统外部的变化
  * 参与者希望从系统得到什么信息
  * 参与者是否希望被告知意外的变化

* Reviewing a Use-Case 审查

  * 参与者是否还能采取其他的行动？
  * 参与者是否有可能遇到错误情况，可能是什么
  * 参与者是否在某个时候遇到其他行为，是什么？

* activity diagram【通过提供程序流程的图表来补充用例】

  <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210607210019184.png" alt="image-20210607210019184" style="zoom:80%;" />

* swim lane diagram【表示活动流程同时指明哪个参与者或分析类负责活动矩阵描述【多个参与者的流程图的感觉】】

  ![image-20210608102207658](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210608102207658.png)



### Ch.10 Requirements Modeling: Class-Based Methods 基于类的



#### O-O(Object-Oriented)analysis

* Classes and objects/Attributes and operations 

* Encapsulation 封装

* Class Hierarchy 层次结构

  ---

#### class Diagram

#### CRC Modeling

* C：class类名
* R：responsibilities职责，该类包含的属性与操作
* C：collaborator协作者，完成职责所需的信息
  * 协作确定类与类之间的关系

    * is-part-of 属于某个聚合类一部分的所有类
    * has-knowledge-of 一个类必须从另一个类中获取信息
    * depends-upon 两者之间连两个类不符的，比如头与身体，存在依赖关系

![image-20210608103824292](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210608103824292.png)



### Ch.11 Requirements Modeling: Behavior, Patterns, and Web/Mobile Apps

#### Behavioral Modeling

* 在行为建模中，必须考虑两种不同的状态特征

  * 各个类的状态【在执行功能的时候】
    * 类状态分为
      * 被动状态（某个对象所有属性的当前状态）
      * 主动状态（对象进行持续变换或处理时的当前状态）
  * 系统的状态【系统执行功能时，从外部观察到的】



#### State Diagram【 Behavior, Patterns】

#### Sequence Diagram

* 顺序图【是用例的速记版本】。表明事件如何引发从一个对象到另一个对象的转移

* 【以时间函数的形式显示软件的行为，下面那个窄的矩形代表用的时间】

  ![image-20210609093516942](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210609093516942.png)



#### DFD(Data Flow Diagram)

* 初始版本

![image-20210609094307045](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210609094307045.png)

* 细化版本

  ![image-20210609094547018](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210609094547018.png)





#### Specification Guidelines【规范指南：编写软件规范的要求】

* 使用分层格式【layer format】，随着层次的深化，提供越来越多的细节
* 用一致的图形符号，并一致地用文本术语
* 定义所有首字母缩写词【不能存在二义性】
* 要包含一个说明目录，包括索引和词汇表
* 简洁，明确的写作风格
* 将自己放在读者位置上思考



#### Requirements Modeling for WebApps

* ##### 产品内容分析content analysis【应用提供的】

  * 文本
  * 图形和图像
  * 视频和音频

* ##### 交互分析interaction analysis【用户和app交互的反应】

  * 用例

* ##### 功能分析functional analysis【内容之间的操作，或者独立于内容但有用的操作】

  * 已定义的用例【将应用于webapp内容的操作，意味着其他处理功能】

* ##### configuration analysis配置分析

  * 关注方面

    * 环境
    * 基础设施infrastructure

  * configuration model

    * server-side服务器端
      * 必须指定服务器硬件和操作系统环境
      * 必须考虑服务器端的互操作性
    * client-side用户端
      * 识别浏览器配置的问题
      * 测试要求要定义好

    

* ##### navigation analysis导航分析【关注总体需求】		

  * 用户交互的每个点应该提供完整的导航地图或菜单



### Ch.12 Design Concepts

#### Good software design

* firmness坚固（程序不存在妨碍其功能的缺陷）
* commodity适用（适合开发的目标，适合预期的目的）
* delight愉悦（使用起来愉悦）

#### **4** Designs

* data/class design 数据设计/类设计
  * 将分析类转化成实现类和数据结构【CRC图中定义的对象和关系，以及类属性和其他表示法描述的详细数据内容为数据设计活动提供基础】
* architecture design 体系结构设计
  * 定义了软件的主要结构化元素之间的关系，可满足系统需求的体系结构风格和模式以及影响体系结构实现方式的约束【可从需求模型导出，表示基于计算机系统的框架】
* interface design 接口设计
  * 描述了软件与协作系统之间，软件和使用人员之间是如何通信的。接口意味着信息流和特定的行为类型【使用场景和行为模型为接口设计提供了大量信息】
* component-level design 构件级设计
  * 将软件体系结构的结构化元素变换成对软件构件的过程性描述，从基于类和行为的模型中获得信息

![image-20210609114535939](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210609114535939.png)

#### **10** Design Principles

* 设计过程不应存在“隧道视觉”【狭隘，坐井观天】
* 该设计应可追溯到分析模型。
* 这个设计应该善于利用已有的东西，不要从头来
* 设计应“尽量减少软件与现实问题之间的知识距离”[DAV95]。
* 设计应保持统一和一体化。
* 设计结构应适应变化。
* 设计结构应轻微降级，即使遇到异常数据、事件或操作条件（例如。www.12306.cn).
* 设计不是编码，编码不是设计。
* 设计应该在创建时进行质量评估，而不是在事实之后。
* 应审查设计，以尽量减少概念（语义）错误



#### **Modularity**: Trade-offs【模块化（数据和功能的划分）要权衡】

![img](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/wps3.jpg)

#### 设计概念

#### **Information Hiding**

* 信息隐藏的原因【每个模块对其他模块隐藏自己的设计决策】
  * 减少“副作用”的可能性
  * 限制全局对局部设计决定的影响
  * 强调通过控制接口通信
  * 阻止使用全局数据
  * 得到封装——高质量设计的属性
  * 得到高质量的软件

####  High Cohesion

* 凝聚性，模块相对功能强度【一个凝聚性强的模块可以执行单个任务，不需要交互】

#### **Low Coupling**

* 耦合性，表明模块之间相互依赖性【耦合性取决于接口的复杂性，对模块进行输入或引用的点以及通过接口传递的数据】





#### **5** **Design Model Elements**

* data elements

  * data model-->data structures，database architecture

  * data modeling步骤

    * 检查数据对象【独立于处理】

      * 数据对象
        * 必须被软件所理解的组合信息【一般具有不同的属性】的表示（可以是外部实体，事物，事件）
        * 对于数据对象的描述包含了合并数据对象以及属性
        * 数据对象只封装数据，没有对数据操作的引用

      * relationship【数据对象以不同的方式连接】

    * 关注数据域

    * 在用户的抽象级别上创建模型

    * 指示数据对象之间的关系

* architectural elements【相当于平面图，一组相互联系的子系统】

  * 体系架构模型三个来源
    * information【关于需要构建软件的应用程序领域的信息】
    * specific requirements【特定的需求模型元素，如数据流图，分析类，它们对当前问题的关系和协作】
    * architecture patterns and style【体系结构模式的可用性域样式】

* interface elements【相当于一组门等的详细图】

  * 接口是一组操作，描述了类的外部可观察行为，并提供了对其公共操作的访问

  * 重要的元素

    * user interface【UI】
    * external interface to other system【与其他系统之外的外部接口】
    * internal interfaces between various design components【各设计部件之间的内部接口】

  * 一般使用UML图建模

    <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210610103831025.png" alt="image-20210610103831025" style="zoom: 50%;" />

    

* component elements【相当于一个房间的详细图】

  * 描述每个软件组件的内部详细信息

  * 定义

    * data structure【所有本地数据对象的数据结构】
    * algorithmic detail【所有组件处理的算法详细信息】
    * interface【允许访问所有组件的接口】

  * 使用UML组件图，UML活动图，伪代码（PDL）以及流程图进行建模

    <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210610104144937.png" alt="image-20210610104144937" style="zoom:50%;" />

* deployment elements【部署元素】

  * 表明了如何在物理计算环境中分配软件功能和子系统
  * 使用UML部署图建模【显示计算环境但不用指明配置的详细信息】
  * 在设计的后期阶段，需要指明特定的硬件配置的实例表单部署

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210610105213740.png" alt="image-20210610105213740" style="zoom: 33%;" />





### **Ch.13** **Architectural Design**

指系统的一个或多个结构，包括软件的构件，构件的外部可见属性以及他们之间的关系

#### **4** **Architectural Genres**

* data-centered architecture以数据为中心

  可集成性较好，数据存储是被动的，新的构件可以较容易地加入，客户构件之间独立执行任务

  <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210610163608631.png" alt="image-20210610163608631" style="zoom:50%;" />

* data flow architecture数据流

  数据从一个构件到另一个构件中，每个过滤器独立于其上下游的过滤器【后一个是批处理序列】

  <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210610163635233.png" alt="image-20210610163635233" style="zoom:50%;" />

* call and return architecture调用和召回

  易于扩展和修改【

  * 主程序/子程序体系结构】

  

  ![image-20210621203352045](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210621203352045.png)

  * 远程过程调用体系结构【主程序/子程序分布在网络中的多台计算机上】

* object-oriented architecture面向对象

  * 系统构件封装了数据和必须用于控制该数据的操作，通过信息传递进行通信合作

* layered architecture分层

  * 每个层次个桌子完成擦欧总，这些操作逐渐接近及其的指令集。外层完成建立用户界面的操作，内层构件完成建立操作系统接口操作，中间层提供实用工具服务和应用软件功能

  <img src="C:\Users\all\AppData\Roaming\Typora\typora-user-images\image-20210621204432139.png" alt="image-20210621204432139" style="zoom:50%;" />
  
  
  
  * C/S model vs B/S model
  
    * C/S客户端-服务器端
  
      充分调动本地资源
  
    * B/S浏览器端-服务器端
  
      不需要安装包，基本上以服务器端为主，但运输通信量大
  
      

#### Architectural Patterns

体系结构模式在特定环境和一系列限制和约束下处理特定问题。模式提出了能作为体系结构基础的体系结构解决方案。

* concurrency【并发性】：应用程序必须模拟并行性的方式处理多个任务
  * 操作系统流程管理模式【**operating system process management** pattern】
  * 任务调度程序模式【**task scheduler** pattern】
* persistence【持续性】：数据在创建它的进程中一直存在，包含两种模式
  * database management system pattern【数据库管理体系结构】：将数据库管理系统【DBMS】的存储和检索能力应用于应用程序体系结构
  * application level persistence pattern【应用程序级别的持续性模式】：在应用性体系结构中构建持久性特性
* distribution[贡献]：系统中系统或组件在分布式环境中相互通信的方式
  * broker【代理】充当客户机和服务器之间的中间人

#### Mapping Data Flow

* transform flow【状态改变流】

  <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615135013589.png" alt="image-20210615135013589" style="zoom:33%;" />

* transaction flow【比上面多一个形态改变中心】

  <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615135042188.png" alt="image-20210615135042188" style="zoom:33%;" />



#### **Partitioning Program** **Architecture**【分区】

* horizontal partition【水平分区】

  * 为每个主要功能定义模块层次结构的单独分支

  * 使用控制模块来协调功能之间的通信

    <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615135227613.png" alt="image-20210615135227613" style="zoom:33%;" />

* vertical partition【垂直分区】

  * 将决策和工作分开

  * 决策层一般在体系结构的顶部

    <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615135245027.png" alt="image-20210615135245027" style="zoom:33%;" />

* 综合垂直和水平分区

  * 优点

    * 结果在软件中更容易测试

    * 软件更容易维护

    * 减少传播中的副作用【某一部分的故障对其他的部分影响小】

    * 软件更容易扩展

      <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615135300662.png" alt="image-20210615135300662" style="zoom:33%;" />

#### Architectural Description L**anguage (**ADL): UML

体系结构描述语言 提供了一个用来描述软件体系结构的语义【semantics】和语法【syntax】

提供的功能：

* 分解体系结构组件
* 将单独的组件组成成更大的建筑结构块
* 表示组件之间的接口（连接机制）
* 如UML，xArch，UniCon，Wright



### **Ch.14** **Component-Level Design**

#### **7** **Basic design principles**

* the open-closed principle(OCP)开闭原理：模块组件应该开放扩展，但关闭修改
* the Liskov Substitution principle(LSP)利斯可夫替代原理:子类应该可以替换它们的基类
* Dependency Inversion principle(DIP)依赖倒置原则:依赖于抽象而不是具体实现。抽象可以比较容易对设计进行扩展，而不会导致大量的混乱
* the interface segregation principle（ISP）接口隔离原则：特定客户端的接口优于通用的一个接口
* the release reuse equivalency principle (REF)发布复用等价性原则:再利用的规格大小就是发布的规格大小。开发者发布一个控制系统，用于支持维护实体的各种老版本。一般将可复用的类分组打包成能管理和控制的包并作为新版本要比对每个类进行升级 好
* the common closure principle（CCP）共同封装原则：一起变化的类属于一起
* the common reuse principle（CRP）通用重复利用原理：不能一起重复利用的类不应该组合在一起



#### **Component Level Design**【指导方针】

* cohesion【内聚性】
  * conventional view【常规图】：一个模块的“单一思维”
  * O-O view：内聚性意味着组件或类只封装与类或组件本身密切相关的属性和操作
  * 内聚性的水平如何看
    * functional功能
    * layer层
    * communicational通信
    * sequential顺序
    * procedural程序
    * temporal时间
    * utility功用
* coupling【耦合性】
  * conventional view【常规图】：组件与其他组件和外部世界连接的程度
  * O-O view：类相互联系程度的定性度量
  * 耦合性的水平如何看
    * content内容
    * common
    * control
    * stamp标记
    * data
    * routine call程序调入
    * type use
    * inclusion or import包含或导入
    * external外部

#### **Component Design for WebApps**

* content design【内容设计】
  * 以基于网络的视频监控功能为例，其内容组件
    * 表示空间布局（楼层平面图）的内容对象，以及表示传感器和摄像机位置的附加图标
    * 缩略图（姆指）视频采集（每个都是单独的数据对象）
    * 特定摄像机的流媒体视频窗口
  * 这些组件都可以单独作为包命名和操作
* functional design【功能设计】
  * 执行本地化处理以动态生成内容和导航功能
  * 提供适合WebApp业务领域的计算或数据处理能力
  * 提供复杂的数据库查询和访问
  * 与外部公司系统建立数据接口



#### **Component-Based** **Development**

* 组件库标准：OMG/CORBA, Microsoft COM, Sun JavaBeans

* 面对组件可能可以重用的时候，一般考虑
  * 是否有商业现成的( commercial off-the-shelf  COTS)组件可实施该要求
  * 内部开发的可重用组件是否可用于实现该需求
  * 可用组件的接口是否在待构建的系统架构中兼容【compatible】

#### **The** **CBSE** Process ( Component Based Software Engineering）

CBSE activities

* Component qualification
* Component adaptation
* Component composition
* Component update

![image-20210615135408442](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615135408442.png)



### **Ch.15** **User Interface Design**

#### Three Golden Rules

* Place the user in control【把控制权给用户】
  * 以不强制用户执行不必要或不需要执行的操作的方式定义交互模式。
  * 提供灵活的互动。
  * 允许用户交互是可中断和撤销。
  * 随着技能水平的提高，简化交互，并允许定制交互。
  * 向临时用户隐藏技术内部内容。
  * 设计应该允许用户于屏幕上的对象进行直接交互
* Reduce the user’s memory load【减轻用户记忆负担】
  * 减少对短期记忆的需求。
  * 建立有意义的默认值。
  * 定义非常直观的快捷方式。(e.g.Alt+P；CTrl+Z，X，C，V)
  * 界面的视觉布局应该基于一个现实世界的隐喻。
  * 以渐进的方式披露信息
* Make the **interface consistent**【页面保持一致】
  * 允许用户将当前任务放入有意义的环境中【提供指示器（如标题和图标）】
  * 在完整的产品线内保持一致【一个产品线应该采用同一种交互方式】
  * 如果过去的交互模式已经建立了用户期待，则除非万不得已不能改动【如用alt+s来存储文件】



#### **4** **Interface Analysis and Design Models**

* user model：该系统的所有最终用户的配置文件，工程师创立
* design model：软件的数据、体系结构、接口和程序表示，软件工程师建立

后两者可以合并

* mental model 心理模型/系统模型：用户对该界面的心理形象
* implementation model 实施模型:组合了计算机系统的外在表现，结合了所有用来描述系统语法和语义的支撑信息，系统实现者创建

由于这四种模型可能相差比较大，所以界面设计人员要消除差距。当心理和实现模型一致的时候，用户会感到舒服



#### 14 Interface Design Principles【for webapp and mobile app】:

* anticipation预测：应该能预测到用户的下一步
* communication传达：该接口应通信由用户发起的任何活动的状态
* consistency一致性：界面等风格一致
* controlled autonomy受控的自主权：该界面应方便用户在整个WebApp中移动，但应强制执行为应用程序建立的导航约定
* efficiency效率：WebApp及其界面的设计应优化用户的工作效率，而不是设计和构建它的网络工程师或执行它的客户端-服务器环境的效率
* flexible灵活性：让用户可以直接或用另一种随意的方式完成功能
* focus集中性：同一界面要关注用户的首要任务
* human interface objects：存在许多人类用户界面的对象库，这些都可以用
* latency reduction减少延迟时间：采用多任务并行的方式。如果选择没有结果，需要返回东西；在运行中可以出现时钟或进度条来提示；在时间延迟中提供一些娱乐
* learnability学习性：最小化学习时间
* metaphors隐喻的：可以来自用户经验但不需要是现实经验的复制品
* readability可读性：关于风格，字体大小等等要符合不同年龄段人需求
* track state轨道状态：当用户登出，对于用户的一些交互要被记录下来
* visible navigation可见性导航：用户不需要关注导航，相反，通过界面现实和执行函数来用户检索内容并选择

#### **Web / Mobile Apps** **Interface Design** **Workflow**

* 检查分析模型中包含的信息，并根据需要进行细化。
* 开发Web或移动应用程序界面布局的粗略草图。
* 将用户目标映射到特定的界面操作中。
* 定义与每个操作关联的一组用户任务。
* 每个界面操作的故事板屏幕图像。
* 使用来自美学设计的输入来细化界面布局和故事板
* 标识实现该接口所需的用户界面对象。
* 开发用户与界面交互的过程表示。
* 开发该界面的行为表示法。
* 描述每个状态的接口布局。
* 细化并审查界面设计模型。





### **Ch.16** **Pattern-Based Design-->Reuse**

#### Three-part rule**: **

* **context, **
* **problem, **
* **solution**

环境让读者理解问题的所在环境，什么解决方案是适合该环境的





#### Frameworks: An implementation-specific skeletal infrastructure

* * 用于设计工作的特定于实施的骨骼基础结构。
  * 是一种“<u>**可重用的迷你体系结构**</u>，为软件抽象系列提供通用结构和行为，以及环境……它指定它们在给定域内的协作和使用。”
  * 不是体系结构模式，而是具有“插点”（插入点）（也称为钩子和插槽（钩子与插槽））的框架，使其能够适应特定问题域。

* framework和pattern的区别

  * 模式更加抽象。框架可以用代码表示，但模式的例子才能用代码表示。框架可以用工程语言表示，同时可以直接用
  * 模式是较小的结构元素。典型的框架包含许多模式
  * 框架更加专门化。框架只能用于特定的应用领域，而模式范围较广

* ##### framework和architectural的区别

  * 框架不是一种体系结构模式，是一种插接点的骨架
  
  

#### Pattern-Based Design in Context 

![image-20210615135914419](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615135914419.png)

#### Common Design Mistakes

* 您没有花费足够的时间来理解潜在的问题、其环境和约束，因此，您选择了一个看起来正确但不适合所需的解决方案的模式。
* 一旦选择了错误的模式，您将拒绝查看错误，并强制使其适合该模式。
* 在其他情况下，问题的约束是您选择的模式没有考虑的，从而导致错误或不匹配。
* 有时模式应用过于纸上谈兵，问题空间没有实现所需的适应



**Architectural****/ Component-Level/** **UI/** **WebApp/ Mobile Apps** Patterns



#### architectural pattern

体系结构模式解决了诸如并发性【concurrency】、持久性【persistence】和分发性【distribution】等问题

【如厨房系统存在食物存储，厨具用于完成任务，工作流程

还有如工作台，墙，地板等其他】



#### component-level pattern

* 提供了一个经过验证的解决方案，可以解决从需求模型中提取的一个或多个子问题
* 在许多情况下，这种类型的设计模式侧重于系统的一些功能元素
* 分类【举例】
  * the design sub-problem【设计子问题】：如我们如何获得任何安全家园设备的产品规格和相关信息
  * search-related pattern【搜索相关模式】：帮助向导，搜索区域，搜索提示，搜索结果，搜索框

#### user interface pattern

在该内容下包括pattern【所用到的模式】，brief decription，details，navigation elements

* page layout 介绍页面（网站）或不同屏幕显示（交互式应用程序）
* forms and input 考虑各种设计技术来完成表单级的输入
* tables 为创建和操作各种表格数据提供设计指导
* direct data  manipulation 地址数据的编辑、修改和转换。
* navigation 协助用户浏览层次化菜单、网页和交互式显示屏
* searching 通过网站内维护或通过交互式应用程序访问的持久数据存储包含的信息启用特定于内容的搜索
* page elements 实现网页或显示屏上的特定元素
* E-commerce 针对网站，这些模式实现了电子商务应用程序中的循环（重现）元素
* whoile UI



#### mobile app pattern

* mobile user interface pattern
  * 签入屏幕、地图、弹出窗口、注册（报名、签约）流、自定义选项卡导航，调用程序
* mobile user interface pattern【web不提倡移动，但mobile太小，所以相反】
  * domain model，lazy acquisition，model-view-controller，pagination，active object

#### web app pattern

* 在界面设计的时候可能不一样，所以可能采用不同的模式
* 包含
  * information architecture patterns【和信息空间的所有结构相关，与用户如何交流相关】
  * navigation patterns
  * interaction patterns【界面如何对用户的特定操作进行反映】
  * presentation patterns表现模式【如何达到最好的可用性时的用户的界面控制功能；如何展现界面动作和影响内容的关系；如何评估有效的内容层次】
  * functional patterns【定义工作流，行为，过程，交流，以及其他算法元素】



### **Ch.17** **WebApp Design**

#### webapp design包含两种设计方式

* artistic ideal表达自己艺术理想
* engineering ideal帮助客户解决问题



#### WebApp Design Quality

* security
  * 拒绝（挫败）外部攻击
  * 排除未经授权的访问
  * 确保用户/客户的隐私
* availability
  * WebApp可使用的时间百分比
* scalability【可伸缩性】
  * WebApp及其接口的系统是否可以处理用户或交易量的显著变化
* time to market
  * 由于软件开发有时间问题，开发出来是否过时？

#### **6** **Design Goals**

* *Consistency*[一致性]
  * content，graphic design，architectural design，interface design，navigation mechanisms要求一致
* identity【建立一个适合于商业目的的“身份”，wabapp的名片要合适，微信一看就知道是什么】
* robustness【稳健性】
  * 用户期望提供与用户需求相关的强健的内容和功能
* navigability
  * 设计方式直观且可预测
* visual appeal
  * 内容的外观、界面布局、色彩协调、文本、图形等媒体的平衡，导航机制必须吸引最终用户
* compatibility
  * 具有所有适当的环境和配置



#### **WebApp Design Pyramid**

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615141837990.png" alt="image-20210615141837990" style="zoom:50%;" />

##### （一）interface design 

* interface design principle
  * focus【WebApp界面（及其呈现的内容）应始终集中在手头的用户任务上】
  * Fitt's law【获取目标的时间是与目标的距离和大小的函数】
  * Human interface object【已经为WebApps开发了大量可重用的人界面对象库】
  * latency reduction【WebApp应使用多任务，让用户像完成操作一样继续工作】
  * learnability【WebApp界面应该被设计为最小化学习时间，一旦学习了，就可以最小化WebApp重新访问时所需的重新学习】
  * maintain work product integrity【维护产品的完整性，必须自动保存一个工作产品】
  * readability【通过界面提供的所有信息都应老少皆能读取】
  * track state【在适当时，应该跟踪和存储用户交互的状态，以便用户可以登录并稍后返回，以获取她离开的位置】
  * visible navigation【设计良好的WebApp界面提供“用户在同一位置进行工作的错觉】

（二）aesthetic design【graphic design，作为技术的补充】

* layout issue
  * 不要害怕空白的空间。
  * 强调其内容。
  * 组织从左上角到右下角的布局元素。
  * 将导航、内容和功能分组。
  * 不要使用滚动条来扩展空间。
  * 在设计布局时，请考虑分辨率和浏览器窗口的大小。

（三）content design

* 要求

  * 开发一种针对内容对象的设计表示法
    * 对于WebApps，内容对象与传统软件的数据对象更加紧密
  * 表示实例化彼此关系所需的机制
    * l类似于描述的分析类和设计组件之间的关系
  * 内容对象具有的属性包括特定于内容的信息和作为设计的一部分指定的特定于实现的属性

  ![image-20210615143906354](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615143906354.png)



（四）architecture design【建筑设计与界面设计、美学设计和内容设计并行进行】

* content architecture

  * 内容体系结构侧重于内容对象（或组合对象）对于演示和导航的结构方式

  * 其中the term information architecture用于表示（暗示）结构，从而导致更好地组织、贴标签、导航和搜索内容对象

  * 分类

    * linear【必须有先决条件才能出现， 特殊的信息需要特殊的顺序才能看到】

    <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615144443593.png" alt="image-20210615144443593" style="zoom: 33%;" />

    * grid【结构可包含两个/以上的维度如横向表示提供物体 的团体纵向表示某一团体提供的物品】

      <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615144538865.png" alt="image-20210615144538865" style="zoom:33%;" />

      * network【面向对象的，灵活但复杂】

        <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615144616980.png" alt="image-20210615144616980" style="zoom: 50%;" />

      * Hierarchy【等级结构，最常见的，当然不同于13章中等级结构是只能垂直来的，这个可以横向来的】

        <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615144848813.png" alt="image-20210615144848813" style="zoom: 50%;" />

* webapp architecture

  * 解决了应用程序用来管理用户交互、处理内部处理任务、效果导航和呈现内容的结构化方式
  * MVC architecture
    * model
      * 所有内容对象
      * 对外部数据/信息源的访问
      * 所有特定于应用程序的处理功能
    * view
      * -表示内容和处理逻辑
      * 对外部数据/信息源的访问
      * 最终用户需要的所有处理功能。
    * contorller
      * 管理对模型和视图的访问，并协调它们之间的数据流

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615145059007.png" alt="image-20210615145059007" style="zoom:50%;" />



（五）navigation design

* 要求

  * 首先要考虑用户层次结构和相关的用户集【每个操作者使用WebApp可能有些不同，因此有不同的导航要求】

  * 当每个用户与WebApp交互时，她会遇到一系列的导航语义单元(NSUS)

    * navigation semantic units（NSUs）导航语义单元

      * 一组协作以满足相关用户需求的子集的信息和相关导航结构【包括导航路线和导航信息等等组合而成的一个大的系统】

        <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615150205546.png" alt="image-20210615150205546" style="zoom:50%;" />

    * navigation syntax【导航语法，以下几项用于构建NSU】

      * *Individual navigation link*【基于文本的链接，图标，按钮和开关，以及图形隐喻(隐喻】
      * *Horizontal navigation bar*【水平导航栏】
      * *Vertical navigation column*【垂直导航栏】
      * tabs【只不过是导航栏或列的变体】
      * *Site maps*【提供一个全方位的内容选项卡，以便导航到WebApp中包含的所有内容对象和功能，一般给爬虫用户用的】



（六）component-level design

* webapp实现的功能
  * 执行本地化处理以以动态方式生成内容和导航功能
  * 提供适合WebApp业务领域的计算或数据处理能力（例如。双“十一”购物打折)
  * 提供复杂的数据库查询和访问
  * 与外部公司系统建立数据接口



### **Ch.18** **MobileApp Design**

#### **Development Process Model**【开发过程模型】

* formulation【阐述】
* planning【计划】
* analysis【分析】
* engineering【编程】
* implementation and testing【实施和测试】
* user evaluation【用户评价，比常规流程多了这项】



#### **MobileApp Design Mistakes:**

* complexity【需要避免过多的功能】
* inconsistency【不一致】
* overdesigning【过度设计】
* lack of speed【性能速度不好】
* verbiage【冗词】
* Non-standard interaction【非标准的交互，如用ctrl+p代表粘贴】
* Help-and –FAQ【Frequently Asked Questions，常见问题解答】

#### **MobileApp Design** **Best Practices**【指南】

* 识别观众【用户】
  * 软件来源应该是用户，可以分为有经验的用户和缺乏经验的，针对不同用户可能有不同要求
* 环境使用的设计
  * 不同的软件使用的环境，情景不同
* 简单性与懒惰之间的界限
  * 在手机上设计直观的界面要比大设备上设计难，
* 使用平台的优势
  * 比如触屏这一未来所有用户都会的
* 让滚动条和高亮更加明显
  * 在触屏情况下，由于滚动条太小，所以一般难以设置，
* 发现高级功能
  * 比如热键和快捷方式帮助用户更快的完成任务
* 使用清晰和一致的标签
* 一些简单的图标不应该牺牲用户理解去设置
* 长滚动形式（胜过）多个屏幕
* 支持用户的个性化需求

### **Ch.19** **Quality Concepts**

#### Software Quality:（Quality Dimension【David Garvin提出】）

* durability 耐久性，可维护性
* serviceability 适用性，在短时间内接受维护与改正
* aesthetics 审美
* perception 感知，一般情况下，人都会有自己对于质量的看法





#### Software Quality Dilemma

* 如果软件不好，没人要；
* 如果花过多的时间与精力来构建绝对完美的软件，则不值当
* 如果超过市场保鲜期，则资源浪费
* 所以软件可以不完美但不会被人家拒绝

#### 	good enough software

* 提供用户希望的高质量功能与特性，也存在一些模糊或有bug的功能与特性
* 当然，这种good enough software并不适合所有情况。如果对于较小的公司，则这种软件可能导致公司声誉受损，受到诉讼等

#### **3** Cost of Quality

* 预防成本prevention costs
  * quality planning 计划与协调所有质量控制和质量保证所需管理活动的成本
  * formal technical review 为开发完整的需求模型和设计模型所增加的技术活动的成本
  * test equipment 预测计划的成本
  * training 与这些活动有关的所有培训的成本
* internal failure costs 内部成本
  * rework 为纠正错误进行返工的成本
  * repair 返工时无意产生的副作用
  * failure mode analysis 组织为评估失效的模型而收集的数据
* extemal failure costs 外部故障成本
  * complaint resolution解决投诉的方案
  * product return and replace产品的退货与替换
  * help line support帮助热线【客服】
  * warranty work保修

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210610124418742.png" alt="image-20210610124418742" style="zoom: 67%;" />



#### **3** **Impact of Management Decisions**【管理决策的影响】

* estimation decisions估算决策。

  * 一般团队确保交付日期和里程碑是合理的，较少给软件团队提供项目估算数据.在确定交付日期和制定总预算之前，很少进行估算决策。以确保交付日期和里程碑是合理的
* scheduling decisions进度安排决策

  * 创建项目计划时未注意任务依赖项
    * 对每一场危机产生的反应，而不是建立监控风险的机制，可能导致产品质量降低
* risk-oriented decision
  * 风险管理是软件工程的关键属性。很多团队在安排发展实践表的时候过于乐观，导致质量不好；





### **Ch.21** **Software Quality Assurance** （**SQA**，软件质量保证）

#### elements of SQA

* standards
  * 标准。保证任务遵循所采用的标准，工作产品符合标准
* review and audits【审查和审计】
  * 评审和审核。技术评审由软件工程师执行，发现错误。审核由SQA人员执行，确保软件工程工作遵循质量准则
* testing
  * 发现错误
* error/defect collection and analysis
  * 错误/缺陷收集与分析。了解错误如何引入以及什么样的软件活动最适合消除他们
* change management
  * 变更管理。减少混乱
* education
  * 通过对软件工程师，项目经理，其他利益相关者的教育来改善关键工程
* vendor management【供应商】
  * 通过建议供应商应该遵循的具体的质量做法，将质量要求写入与供应商的合同中
* security management
  * 安全防卫。如防火墙
* safety
  * 安全。评估软件失效的影响，并负责减少风险
* risk management
  * 这件事一般由软件工程师考虑，但这里是为了保证风险管理活动适当的进行，并建立应急计划



#### SQA Goals:

* requirements quality
  * 需求模型的正确性【correctness】、完整性【completeness】和一致性【consistency】将对后续所有工作产品的质量产生强烈影响
* design quality
  * 所有的设计模型元素都应由软件团队进行评估，以确保其具有高质量，且设计本身符合要求
* code quality
  * 源代码和相关的工作产品（例如，其他描述性信息）必须符合当地的编码标准，并表现出能够促进可维护性的特性
* quality control effectiveness【质量控制的有效性】
  * 软件团队应以最高可能实现高质量结果的方式应用有限的资源

![image-20210622163112894](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210622163112894.png)

#### **Six-Sigma** for Software Engineering

数字越大，缺陷出现的概率越小

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616192940598.png" alt="image-20210616192940598" style="zoom: 50%;" />





#### software reliability【可靠性】

* <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616193128161.png" alt="image-20210616193128161" style="zoom:50%;" />
* <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616193101144.png" alt="image-20210616193101144" style="zoom:50%;" />
* MTTF：**Mean Time To** **Failure**
* MTTR：**Mean Time To** **Repair**【对可维护性的间接测试】
* MTBF：平均失效间隔时间





#### **Ch.20** **Review Techniques**

#### **Errors** **vs** **defects**

* error：在将软件发布给最终用户之前发现的质量问题
* defect: 只有在软件发布给最终用户之后才会发现的质量问题

#### **Defect Amplification Model**【缺陷放大模型】

![image-20210615154751216](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615154751216.png)

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615154906215.png" alt="image-20210615154906215" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210615154927805.png" alt="image-20210615154927805" style="zoom:50%;" />

#### **Informal Reviews**【非正式审查】

* **pair programming**【结对的编程】
  * 在创建工作产品（设计或代码）时进行连续审查
  * 其好处是立即发现错误，从而获得更好的工作产品质量

#### **Formal Technical Reviews**（**FTR**）

由软件工程师掌控的软件质量管理活动

* FTR的目标【FTR实际上是一类包括*walkthroughs（走查)和inspections(细查）*的评论】

  * 发现任何软件表现出来的功能、逻辑或实现错误
  * 验证所审查的软件是否符合其要求
  * 确保软件已按照预定义的标准表示
  * 实现以统一方式开发的软件
  * 使项目更易于管理

* FTR形式----The review meeting

  * 应该有三到五人（通常）参与审查。
  * 应提前准备，但每个人的工作时间不超过两个小时。
  * 评审会议的持续时间应少于两个小时。
  * 重点是<u>工作产品</u>（例如，需求模型的一部分、详细的组件设计、组件的源代码）

* 参与人员：

  * producer：通知项目负责人，工作产品已完成，需要进行审查
  * review leader：评估产品的准备情况，生成产品材料的副本，并将其分发给两名或三名审查人进行预先准备。
  * reviewer：预计会花一到两个小时检查产品，做笔记，熟悉工作
  * recorder：记录（书面）评审人的所有重要问题

* 过程

  * preparation phase：producer--》review leader--》reviewer--》problem lists
  * perform phase：producer introduction--》reviewer raise problem--》recorder
  * track phase：conclusion，SQA report

  

* ~~sample-driven review（SDRs）【SDR试图量化那些作为完整FTR的主要目标的工作产品】~~

  * ~~检查每个软件工作产品的小部分ai，fi代表在ai中发现的故障数。~~
  * ~~制定一个总估计值，将fi乘以1/ai。~~
  * ~~根据每个故障数量的总估计值，按工作产品的降序排序。~~
  * ~~将可用的审查资源集中在工作产品i中估计故障数量最多的工作产品上~~



#### **10** **Review Guidelines**

前期准备

* 限制参加人数，坚持提前准备。
* 为每个可能被审查的产品制定一个检查清单。
* 为FTR分配资源和计划时间。
* 设置议程（议事日程）并进行维护。
* 对所有评审人员进行有意义的培训。

过程

* 检查产品，而不是生产者
* 限制辩论和反驳（反驳）。
* 阐明（确切说明）问题区域，但不要试图解决所有问题。
* 做好书面的笔记。
* 回顾一下你早期的评论。





### **Ch.22** **Software Testing Strategies**

#### **General** **testing strategy** **for software product:**

**---** Conceptual Testing、Unit Testing、 Integration Testing 、Validation testing、 System Testing、 User Experience Testing、Stability Testing、 Connectivity Testing、 Performance Testing、Compatibility Testing、 Navigation Testing、 Security Testing、 Certification Testing





#### Verification VS Validation

* verification【验证，关注我们生产的产品对吗】
* validation【确认，我们是否生产了正确的产品】
  * 软件测试只是SQA的一个元素。】质量必须建立在开发过程中，
  * 事后不能使用测试来增加质量



#### Independent Test Group **VS**  Developer Group

* developers
  * 理解该系统，将测试“温和”，
  * 并由“交付”驱动
* independent test group【ITG】
  * 必须了解这个系统，但会试图打破它。
  * 而且是由质量驱动的



#### Unit Testing

侧重于软件设计的最小单元的验证工作，利用构件级设计描述作为指南，测试重要的控制路径以及发现模块内的错误。侧重于构件内部处理逻辑和数据结构。

一般被认为是编码的附属工作，可以在编码之前，或之后进行。



<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616200718664.png" alt="image-20210616200718664" style="zoom:50%;" />

* 测试内容
  * 接口：保证被测程序单元的信息可以正常流入流出
  * 局部数据结构：确保临时存储的数据在算法的整个执行过程中保持完整性
  * 执行控制结构中的独立路径：保证模块中所有语句至少执行一次
  * 测试边界：确保模块在边界处仍能正常执行
  * 最后对所有错误处理路径进行测试

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616200808487.png" alt="image-20210616200808487" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616200830199.png" alt="image-20210616200830199" style="zoom:50%;" />

* 
  * 由于构件不是独立的程序，所以要给每个单元卡法驱动程序和桩程序。
  * 驱动程序只是“主程序”，只接收测试用例数据，并将数据传给构件。而桩程序用于替代从属于或者被调用的模块

* 对于OO【object-oriented】软件的unit testing
  * 相当于class testing
  * 不能单独测试操作（层次结构）
  * 由类操作和状态行为驱动，而不是跨模块接口的算法细节和数据流驱动的



 

#### Integration Testing【集成测试】

* 对于常规软件

  * top-down

    * 优点：尽早确定主控点或者决策点

    * 缺点：不能往上流【集成】

    * 可分为深度优先【0，1，3，4，2】和广度优先【0，1，2，3，4】

    * 利用直接从属于主控模块的所有模块代替桩模块

      
      
      <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616201342140.png" alt="image-20210616201342140" style="zoom:50%;" />

  * bottom-up

    * regression testing：重新执行一些测试的子集，以确保更改不会传播意外的副作用

    * 这个就没必要使用桩模块，只要将簇和上层模块连接的时候去掉驱动模块即可

      
  
      <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616201544299.png" alt="image-20210616201544299" style="zoom:50%;" />
  
  * smoke testing【适合于需要关键时间的项目】
  
    * 在修复一个bug后，需要对整体进行运行，检查是否破坏整体平衡性并且解决问题
    * 将已经变为代码的软件构件集成到构造【包括所有的数据文件，库，可复用模块以及功能所需的工程化构件】中。每天将构造和其他构造集成起来冒烟测试
    * 不一定穷举，但总能暴露一些问题
    * 好处
      * 降低集成风险
      * 提高最终产品质量
      * 简化错误的诊断和修正
      * 易于评估进展
    
    ![image-20210616202009232](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616202009232.png)


* 对于面向对象软件
  * thread-based testing【基于线程的测试】：测试响应一个系统输入或事件所需的所有类
  * use-based testing【基于使用的测试】：首先测试独立类（使用的服务器类很少的类），然后测试使用它们的依赖类
  * cluster testing【簇测试】：测试协作类组来测试交互错误



#### **WebApp** **&** **Mobile** **Testing**

* user experience testing【用户体验测试】：确保应用程序满足利益相关者可用性和可访问性期望
* device compatibility testing【设备兼容性测试】：在不同的设备上测试
* navigation testing
* performance testing【性能测试】：测试非功能要求
* connectivity testing【连接测试】：测试app连接应用的能力
* security testing【安全测试】：确保应用程序满足利益相关者安全
* testing-in-the-wild【野外测试】：测试app在实际应用的状况
* certification testing【认证测试】：应用程序符合分配标准



#### **High Order Testing**

确认测试【集成测试结束后，已经完整，并且接口错误找到，则集中于用户可见的动作和可识别的系统输出】

* validation testing【验证测试】：软件的功能和需求相符合的测试重点在需求
* configuration testing【配置测试】：确保所有软件配置元素正常开发，编写并支持活动的必要细节 
* Alpha/Beta testing：重点在用户

系统测试

* system testing：重点在系统集成
* recovery testing【恢复测试】：迫使软件以多种方式失败，并验证恢复是否正确执行
* security testing【安全测试】：确保应用程序满足利益相关者安全
* stress testing【压力测试】：以需要异常数量、频率或体积的资源的方式执行系统
* performance testing【性能测试】：测试集成系统环境下软件的运行时性能
* deployment testing【部署测试】：软件需要在多个平台和操作环境中进行



#### **4** **Debugging Techniques**

* **brute force / testing**【蛮力测试，在内存中设置测试点】
  * 最常用但低效
* **backtracking**【回溯法，适合小程序，从有症状的地方开始，追溯】
* **induction**【归纳，3W1H table【what，where，when，how】】
  * 原因排除法，对错误出现的相关数据进行组织，以分离出潜在的错误原因。
* **deduction**【推演，导致错误的原因消除】
  * 在书上，induction和deduction属于一种





### **Ch.23** **Testing** **Conventional** **Applications**【常规应用】

#### **White-Box** **Testing**

* 保证所有声明以及条件都被执行一次

* <u>**重要概念：Cyclomatic Complexity V(G)**</u>

  * ![image-20210616212222559](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616212222559.png)
  * ![image-20210616212243165](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616212243165.png)

* control structure testing

  ![image-20210616212511604](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210616212511604.png)

  * 注意simple loop中，取左边界点以及其周围点，取右边界点以及其周围点，取中间范围的任一点

#### Black-box testing

*  **<u>Equivalence Partitioning【等价性划分】</u>**

   * 等价类表示输入条件的一组有效或无效状态，因此没有特定的理由选择一个元素而不是另一个元素作为类代表
   * 指南
     * 如果输入条件指定了范围，则定义一个有效的和两个无效的等价类。
     * 如果输入条件需要特定值，则定义一个有效的和两个无效的等价类。
     * 如果输入条件指定集合（集合）的成员，则定义一个有效和一个无效的等价类。
     * 如果输入条件是布尔值，则定义一个有效的和一个无效的等价类。

*  **<u>Boundary Value Analysis【边值分析】</u>**

   * 指南
     * 如果输入条件指定了一个由值a和b限定的范围，则测试用例应包括a和b，位于a和b上方和下方的值（假设为<b）。
     * 如果输入条件指定了值和数量，则测试用例应执行最小和最大值，以及略高于和略低于最小和最大值的值。
     * 对输出条件应用准则1和2，测试用例应设计为生成最小和格言输出报告。如果内部程序数据结构有边界（例如，大小限制），则一定要测试边界。

### **Ch.24** **Testing** Object-Oriented Applications

#### classes

* attributes
* operations
* messages



#### **Class Model Consistency-》CRC **Model

* 重新定义CRC模型和对象-关系模型
  * 对这两个模型做交叉检查，确保需求模型所蕴含的所有协作都正确地反映在模型中
* 检查每个CRC索引卡的描述，以确定委派（委派的）责任是否是合作者定义的一部分
* 反转连接，以确保每个被请求提供服务的协作者都收到了来自合理来源的请求
* 使用上一步中检查的反向连接，确定是否需要其他类或责任是否正确分组在类之间
* 确定广泛要求的责任是否可以合并成一个的职责

#### **Testing Methods:**

面向对象地测试方法

* fault-based testing【基于故障的测试，面向对象地测试】：测试仪将查找合理的故障（即，系统实施中可能导致缺陷的各个方面）。为了确定这些故障是否存在，测试用例被设计为执行设计或代码。
* Scenario-Based Test Design【基于场景的测试设计】：集中于<u>用户做什么</u>，而不是产品做什么。这意味着捕获用户必须执行的任务（通过用例），然后将它们及其变体应用作为测试。

类级可应用地测试方法

* class testing and the class hierarchy【类级划分测试】：继承并不能排除（避免）对所有派生类的彻底测试的需要。事实上，它实际上可能会使测试过程复杂化
* <u>**random testing**</u>【随机测试】

  * 步骤
    * 识别适用于类的操作，
    * 定义其使用的约束，
    * 定义最小测试序列【定义类（对象）最小生命历史记录的操作序列】
    * 生成各种随机（但有效的）测试序列，
    * 练习其他（更复杂的）类实例生命历史记录
* <u>**partition testing**</u>【分区测试】

  * 就像传统软件的等价分区一样，减少了测试类所需的测试用例的数量
  * 分区的方式
    * state-based partitioning【基于状态的分区】
      * 根据操作更改类状态的能力进行分类和测试
    * attribute-based partitioning【基于属性的分区】
      * 根据操作所使用的属性对其进行分类和测试
    * category-based partitioning【基于类别的分区】
      * 根据每个操作所执行的通用函数进行分类和测试操作



### **Ch.25** **Testing Web Applications**

![image-20210617093320378](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617093320378.png)



### **Ch.26** **Testing Mobile Applications**

#### **9** **Mobile App Testing**

* Conceptual Testing 【概念测试】
* Unit and System Testing【单元和集成测试】
* User Experience Testing 【用户体验测试】
* Stability Testing【稳定性测试】
* Connectivity Testing
* Performance Testing 
* Compatibility Testing
* Security Testing
* Certification (鉴定) Testing

#### Testing tools[cloud testing]

* mobile page compliance checkers 移动式页面遵从性检查程序
* mobile browsers emulators 移动浏览器模拟器（仿真程序）
* device emulator设备模拟器
* key logging and playback 密钥日志记录（记录）和回放
* network monitors 网络监视器
* mobile analytics collectors 移动式分析数据收集器



### **Ch.27** **Security Engineering**

#### **Analyzing Security Requirements**

由两方面决定

* 与客户合作共同识别必须保护的资产
* 资产受损后的成本
  * exposure
    * 【遭受的损失】指重新创建丢失的系统资产的时间或成本方面的值





#### **Online** **Security Threats**:

* social media
  * 网络（推特、脸书、微信、顶顶、QQ等）通常允许用户开发能够访问用户个人信息的应用程序
* Mobile Application
  * 除了桌面业务的风险之外，还有无线网络要求节点之间信任与合作，这可能被恶意程序利用
* cloud computing
  * 在安全图片中带来了额外的机密性和信任问题，因为它模糊了“内部不信任”和“外部不信任”之间的界限
* internet of things【物联网】
  * 日常对象交流和报告有关其用户及其环境的信息的能力，



#### **Security** **Engineering Analysis**

* security requirements elicitation【引出】
  * 确定用户需要如何与系统资源交互
  * 创建描述导致系统威胁的滥用者故事
  * 用户处理建模和风险分析，以确定系统安全策略【作为非功能需求的一部分】(例如。发生冲突！）
  * 找到可识别解决系统安全缺陷的解决方案的Locate attack pattern【攻击模式】
  
* security model

  是安全性策略的形式化描述

  用处

  * 在设计、编码和审查状态模型期间提供指导
  * 使用正式安全模型可以提高系统的可信度（可信度），因为正确性证明可以用作系统安全案例的一部分

  包括

  * 安全性策略目标、
  * 外部接口要求、
  * 软件安全要求、
  * 运行操作规则、
  * 描述模型和系统对应关系的详细说明

  有些安全模型用状态机表示

  * state model【状态模型】可以帮助软件工程师确保系统允许的一系列状态转换开始和结束处于安全状态
  * 

* measure design
  * 安全性软件的属性
    * sysytem dependence【系统可靠性】，
    * trustworthiness【可信性】，
    * survivability【生存性，在已妥协的情况下系统仍可能继续运行】
  * 安全性度量要以测度【measure】为基础，
    * asset value【资产价值】，
    * threat likelihood【威胁的可能性】
    * 系统漏洞测度
  
* correctness check【正确性检查，是的】
  * 从系统攻击的角度来分析，对于资产的显露度应该在卡法早期就确定；
  * 而由系统用例导出的威胁模型对于风险缓解，监测和管理的安全性部分做出了解释
  * 在建模和构件活动中，
    * 质量保证活动应该包括安全性标准的制定和安全性指南的开发
    * 软件验证活动应确保安全性测试用例是完备的，可以追溯到系统的安全性需求
  * 许多这类的安全性检查应该包括在常规软件工程任务的审核，审查和测试活动中，在此期间收集的数据被分析和总结为一个安全案例

#### **Security** **Assurance**

* 用于显示您已创建了一个安全的产品，以激发最终用户和利益相关者之间的信心
* 安全案例元素【security case elements】
  * security claims【安全索赔】
  * arguments linking claim to each other【索赔的相关讨论】
  * evidence（review，proof）supporting arguments【以及该讨论的支撑证据】

#### Security Risk Analysis

风险影响了项目管理和安全性保证

威胁建模【安全性分析的一种方法，识别可能引发基于软件系统的破坏的威胁；利用项目早期的需求和分析模型完成】步骤

* Identify assets【资产识别】
  * 列出所有敏感信息和知识产权，存储位置，存储方式以及访问权
* Create architecture overview 【创建体系结构概述】
  * 写出系统用例并建立系统构件模型
* Application decomposition 【应用程序分解】
  * 保障在应用软件构件之间发送的所有数据都是有效的
* Identify threats 【识别威胁】
  * 使用攻击树或攻击模式等方法，记录所有威胁（网络，主系统配置，应用威胁）
* Document threats 【把威胁写成文档】
  * 制作风险信息表，详细列出要监测和缓解的每项威胁
* Rate threats【速率威胁，评估威胁】
  * 根据威胁的影响大小以及发生的可能性进行排序，区别对待

 

### **Ch.28** **Formal Modeling and Verification**【形式化模型和验证】

利用基于数学的方式让软件do it right the first time

#### **2** methods

* cleanroom software engineering
* formal methods
* 相同点
  * 两者都需要一种专门的规范方法，而且每种方法都应用一种唯一的验证（认证）方法。
  * 两者都非常严格，而且都没有被软件工程社区广泛使用。



#### **Cleanroom Strategy**[用于增量模型]

* <u>**increment Planning**</u>
  * 增量计划。采用增量策略需求收集
* requirements Gathering
  * 需求综合。给每个增量都定义描述用户级需求
* **Box Structure Specification**【一种method】
  * 框架结构规范。描述了功能规范
  
    ![image-20210623125442804](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210623125442804.png)
  
  * 包括
  
    * black box：说明系统的行为或者系统的部分
  
      ![image-20210623125636856](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210623125636856.png)
  
      * 其中，f代表数学函数，但实际上，可能由自然语言表示
  
    * state box：用一种方式封装了状态数据和服务（操作）
  
      ![image-20210623125850511](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210623125850511.png)
  
      * 其中T表示内在的系统状态
      * 则这个过程：S×T--》R×T‘
  
      * 是对状态机的简单概括
      * 用数据抽象来确认状态变化
  
    * clear box：state box中隐含的函数在clear box中定义
  
      * 将black box中替换成一系列操作【可以合并有条件的内容】
      * 可以被细化成低水平clear box，就如继续细化步骤
* Formal Design
  * 正式设计。规范（称为“黑箱”）迭代改进（带增量），类似于架构和程序设计（分别称为“状态框”和“透明箱”）
* correctness verification
  * 正确性验证。验证从最高级别的框结构（规范）开始，使用一组“正确性问题”转向设计细节和代码。如果这些问题不能证明规范正确，则使用更正式的（数学）验证方法
* code Generation，inspection，verification
  * 代码生成、检查和验证。以专用语言表示的框结构规范传输成适当的编程语言
* statistical test planning
  * 统计测试计划。计划和设计了一套实施使用的“概率分布”的测试用例
* statistical usage testing【usage probability distribution使用概率分布】
  * 统计使用情况测试。执行从来自目标人群的所有用户可能执行的所有程序的统计样本（上述概率分布）得出的一系列测试
* certification
  * 认证（认证）。一旦完成验证、检查和使用测试（所有错误得到纠正），增量被认证为准备集成

![image-20210619101752188](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619101752188.png)





#### **Formal** **Specification**【正式的技术规范】

* **Desired properties**【所需的属性】
  * consistency, 
  * completeness,
  *  lack of ambiguity;
* **Formal syntax** 【对于规范语言正确的语法】
  * interpreted **in only one way;** 【只能用一种方式解释，无二义性】
* **Consistency** is ensured by **mathematically** **proving**
  * 通过数学证明初始事实可以正式映射（使用推理规则）到规范中的后续语句来确保一致性



### **Ch.29** **Software Configuration Management**【软件配置】

软件配置用于标识变更，控制变更，保证恰当的实施变更，向其他可能的相关人员报告变更

the first law of system engineering【系统工程第一定律】：无论处在系统的什么生命周期，系统都可能变化

#### Software Configuration Item（SCI）

* 包括在软件过程中产生的所有信息（程序、数据、文档等）的项目统称为软件配置【Software Configuration】

  ![image-20210619102630667](C:\Users\all\AppData\Roaming\Typora\typora-user-images\image-20210619102630667.png)

#### **Baselines**【基本线】

一种软件控制管理概念，帮助我们在不严重阻碍合理变更的条件下控制变更；

基线：已经通过<u>正式审评和批准的规格说明</u>或产品，可以作为进一步开发 的基础，并且只有正式的变更控制规程才能改变。【软件配置项在称为基线之前较方便改变，但称为基线后，就不行了】

一旦模型所有部分都通过评审，纠正和批准，该设计模型就成为基线

* System Specification 【系统规范】

* Software Requirements【软件需求】

* Design Specification 【设计规范】

* Source Code 【源代码】

* Test Plans / Procedures / Data 【测试计划，测试者，测试数据】 

* Operational System【操作系统】

   

#### **SCM Repository**[SCM中心存储库]

* SCM存储库是允许软件团队有效管理变更的机制和数据结构
* 存储库执行或促进以下功能
  * data integrity【数据完整性】
  
  * information sharing【信息共享】
  
  * Tool integration【工具集成】
  
  * data intergration【数据集成】
  
  * medthodology enforcement【方法实施】
  
  * document standardization【文档标准化】
  
    ![image-20210623153722319](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210623153722319.png)
    
    * 一个较好的中央存储库能提供的服务
      * 期望从一个复杂的数据库管理系统得到相同的服务类型
      * 特定于软件工程环境的服务类型
    * 功能
      * 集成或直接支持过程管理功能
      * 支持在中央存储库的特定规则和维护数据
      * 提供与其他软件工程工具的接口
      * 能存储各种数据对象

#### **SCM for** **Web & Mobile Engineering**【软件配置管理】

* content
  * 典型的Web或移动应用程序包含大量内容——文本、图形、小程序(Java程序)、脚本、音频/视频文件、表单、活动页面元素、表、流媒体数据以及许多其他内容。-挑战是将这个内容组织成一组合理的配置对象（第29.2.1节），然后为这些对象建立适当的配置控制机制
* people
  * 由于很大一部分Web和移动应用程序的开发继续以一种特别的（特别的)的方式进行，任何参与该应用程序的人都可以(而且经常会）创建内容
* scalability
  * 随着规模和复杂性的增长，小的变化可能会产生深远的影响和意想不到的影响。因此，配置控制机制的严格性应与应用规模成正比。
* politics
  * -谁“拥有”一个应用程序？-谁要对应用程序所显示的信息的准确性负责？-谁能确保在信息发布到现场之前已遵循质量控制流程？-谁应负责进行变更？-谁承担变更的成本

#### 4 Major capabilities of Version control System:

【版本控制系统的主要功能】

* 对于web或mobile App来说，中央存储库必须设立【存储库中存着现有的所有配置要素】
* 每个工程师要创建自己的工作文件【文件中包含在所有时间创建和改变的所有物体】
* 发展工作环境的时钟要同步【避免重复写入冲突】
* 当新的配型要求出现或旧的改变的时候，中央存储库要改变
* 一个配置对象从存储库输入或输出要有日志





### **Ch.30** **Product Metrics**【产品测量】

#### **Measures,** **Metrics** **and Indicators**

* measures测度【提供量化的指标，提供数字对于产品进行度量】 

* metrics度量【量化的测量，如每次发现的错误率】

* indicators指标【几个度量的综合，可以提供对产品的过程进行洞察】



#### **Size-Oriented** Metrics(LOC) vs **Function-Based** Metrics (FP)

##### size-oriented metrics【history】【问题：<u>当然项目的语言也有影响，这样可能错判较好的，但较短的程序</u>】

##### LOC：line of code

* Errors per KLOC
* defects per KLOC
* cost per LOC
* page of documentation per KLOC
* errors per person-month
* LOC per person-month
* $ per page of documentation

###### 依赖于编程语言，惩罚设计良好但较短的程序

##### function point【功能点：对以下项进行评级，加权之和】

![image-20210619110652675](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619110652675.png)



#### **Architectural** **Design Metrics**【体系结构设计指标】

<img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619110740275.png" alt="image-20210619110740275" style="zoom:50%;" />

v(i):进出模块的变量

fout（i）：输出模块

#### **Metrics for** **Source Code:** **Halstead’s Theory**

![image-20210623184819593](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210623184819593.png)

operators：不同的操作员

operands：不同的操作数



#### Maintenance Metrics

* 建议提供软件产品稳定性指示的软件成熟度指数

* 包含以下指数

  * 现有模块数Mt
  * 改变模块数Fc
  * 增加模块数Fa
  * 删减模块数Fd

  ![image-20210619111009016](C:\Users\all\AppData\Roaming\Typora\typora-user-images\image-20210619111009016.png)

当SMI接近1的时候，稳定





### **Ch.31** **Project Management Concepts**

#### The 4P‘s

##### people

* 人包括

  * 团队领导者【发挥人的最大技术和能力】

    * MOI model
      * M:Motivation,动机，激励开发者
      * O：Organization，利用现有成果，将现在的理论转化成最后成果
      * I：ideas/innovation，创新，激励人们去创新

    * 工作：理解问题，自由流动的想法，让所有人知道质量最重要
    * 四个特性：
      * 问题解决（可以确定关键的技术性的，组织性的问题）
      * 管理明确 （关于开发者的一些创新，需要取得控制）
      * 成就（学会奖励新方案/成就来优化项目组）
      * 影响和团队构建（学会理解人）

  * 团队

    * 最好的团队结构取决于管理风格，团队的人数以及人的技术水平以及问题的难度

    * 组件队伍必须考虑的因素

      * 问题难度 
      * 代码的规模，方法点
      * 团队合作的事件
      * 问题的可模块化程度
      * 系统的质量与可靠性
      * 截止日期
      * 项目的交流需求程度

      

      

    * 不利于团队的因素

      * 一种混乱的工作氛围，成员浪费精力，失去对目标的关注（应该有工作所需的所有信息，不轻易改变目标）

      * 由个人、商业，技术带来的高度挫折（尽可能对决定负责，通过了解产品和人员来选择过程模型，避免不当的软件过程）

      * 碎片化/不协调/模型选择不当导致实施困难

      * 对软件团队中角色的模糊定义（建立责任机制，还可以找到正确方式） 

      * 持续的反复接触失败，导致成员失去信心（这个是建立团队为基础的反馈和问题解决技巧）

        

    * 交流问题：工作者距离太远，不确定性，互操作性【现在软件特征】

      * 正式的交流方式包括工程文件，源代码，备忘录，时间表等
      * 正式的人际关系程序侧重质量保证活动，包括审查会议，代码检查等
      * 电子通信包括电子邮件，视频会议等
      * 利益相关网中包括非正式会议帮助解决项目

    * Agile Teams【敏捷团队】

      * 团队成员相互信任

      * 技能分配需要与问题相适应

      * 团队中没有害群之马

      * 团队是自我管理的

        * 有合适的团队结构

        * 用到自由/开放或者同步的范式

        * 自主权

          

###### product

* 作用：得到合理的花销，风险评估，分解工程任务，工程计划表（一般这个是软件工程的第一步）

* 产品目的：明确产品的所有目标

* 产品范围：明确产品的初始数据，方式，行为【范围必须要在管理与技术层面上明确】

  * context（环境）：软件如何适应更大的系统等，以及环境中的约束
  * information objectives(信息目标):用户可见数据，如何输出，输入
  * function and performance（方法与性能）：如何执行使得输入变成输出，是否需要解决任何特殊的性能特性

  

* 对问题的分解 problem decomposition【partitioning/problem elaboration】

  * 一旦产品目的和范围被确定，可供选择的解决方案就确定了，虽然有些小细节需要讨论，但可以让管理者们选择较好的方案，一般被交付期限，预算，个人能力，技术接口，等其他要素约束
  * 分解直至所有方法与问题被定义





###### process

提供了一个框架（可以被度量的），少量的框架就可以应用于所有的项目，而其中，任务，里程碑，工作成果，质量保证点使得整个框架更加适合项目

* 流程框架的建立考虑点

  * 项目特点，使用产品的用户，以及开发者，产品本身的特点，团队工作环境

  * 严格程度【rigor required】

  * 对每个活动定义任务单【包括软工任务，可执行产品，测试点，里程碑】

    ![image-20210604095730441](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210604095730441.png)

  * o

* 合并产品和过程（项目计划伴随着合并产品和过程）

* 过程分解（团队需要灵活地选择最好的模型），对于小的并且与之前类似的项目，建议采用线型方式

* 对于较小的，相关的程序，需要的任务

  * 说明清楚一系列问题
  * 和开发者说明以上问题
  * 共同得到陈述的范围
  * 会看陈述
  * 修改陈述

  

###### project

* 项目问题

  * 开发人员不了解客户需求，产品适用范围不当，变更管理很差，所选的技术会发生变化，ddl不现实，团队缺乏适当技能的人员等等

* 研究项目的常识性问题

  * 正确开始。要充分理解待解决的问题，再设立目标与期望
  * 保持动力。pr要提供鼓励，让人员流动保持到最低。提高质量。
  * 跟踪工作进度。一般生产产品和跟踪进度（正式的技术审核）是质量保证活动的一部分。
  * 进行事后分析。建立一个一致的机制来提取每个项目的经验教训

  

* critical practices关键性实践

  * Formal risk management（正式的风险管理）

  * Empirical cost and schedule estimation（经验成本与进度的估计）

  * Metrics-based project management（基于指标的项目管理）

  * Earned value tracking（收益价值跟踪）

  * Defect tracking against quality targets（对于质量目标缺陷的跟踪）

  * People aware project management（人们关注点的项目管理？）

    

* 实施安排好的，可控的项目的原因：这个是唯一的管理复杂的方式

* 现在软件失败率较高，为了防止这，所以管理者需要避免一些常见的错误，选择合适的方式去规划，执行，控制项目



#### 5种主要的利益相关者及其角色：

* senior managers【经理】
  * 定义经常对项目产生重大影响的业务问题
* project managers【技术组长】
  * 必须计划、激励、组织和控制从事软件工作的从业人员
* practitioners【从业人员，程序员】
  * 提供设计产品或应用所需技术技能
* customers
  * 指定要设计的软件的要求和对结果有外围感兴趣的其他利益相关者
* end-users
  * 一旦该软件发布以供生产使用，他们就会与该软件进行交互

#### **4** **Organizational Paradigms**

团队的组织范式【Constantine提出四种“组织模式”】

* **closed paradigm** 传统的层级结构，传统权力层级，对于原来类型的软件较好，但创新性不高。【高级工程师（计划，协调，审查），技术人员，支持工程师，主程序员（可以有专家，支持人员，软件管理员支持）】
* **random paradigm**松散地构建一个团队，并依赖于团队成员的个人主动性。适合创新型和技术性突破，但难完成有秩序的操作。最好是创新的无序，将创新活力运用于创建高效能团队
* **open** **paradigm**兼具封闭的可控性又有随机的创新型，成员合作完成工作，有丰富的交流和达成共识的决定，适合解决复杂的问题，但没有其他团队效率高
* **synchronous** **(同步的**)paradigm**依赖问题的划分，将队员分成不同组，彼此之间没什么沟通



### **Ch.32** **Process and Project Metrics**

#### **Process** **metrics**【过程测度】

###### 一个流程的有效性--》一个战略视图

* quality-related
  * 关注工作产品和可交付成果的质量
* productivity-related
  * 与所投入的工作量相关的生产工作产品
* statistical SQA(Software Quality Assurance) data
  * 错误分类与分析
* defect removel efficiency
  * 从进程活动传播到活动的错误传播
* reuse data
  * 生成的组件的数量及其可重用性的程度

#### **Project** **metrics** 【项目测度】

###### workflow, real-time approach --》 **A** **Tactical** **View**

工作流程、实时方法--》战术视图

* Effort/time per software engineering task

  * 每个软件工程任务的工作量/时间

* Errors uncovered per review hour

  * 每个审查小时发现的错误

* Scheduled vs. actual milestone dates

  * 计划与实际里程碑日期

* Changes (number) and their characteristics

  * 更改（数量）及其特征

* Distribution of effort on software engineering tasks

  * 软件工程任务的工作量分布

  

#### **Defect removal efficiency**【缺陷消除效率】

* DRE=E/(E+D)
* E:error
* D：defeat

* ~~DREi=Ei/(Ei+Ei+1)——从过程活动到活动的错误传播~~





#### Statistical SQA (Software Quality Assurance) data

error categorization & analysis

测量质量

* 正确性【软件完成所要求的功能的程度】
* 可维护性【遇到错误时，程序能被修改的容易程度】
* 完整性【一个系统对安全性攻击【偶然/蓄意】的抵抗能力】
* 可用性【对使用的容易程度进行量化】

具体指标包括缺陷排除效率（DRE）以及DRE的过程指标

DREi=Ei/(Ei+Ei+1)【传递错误效率】





### **Ch.33** **Estimation for Software Projects**

#### **What to estimate**

* How long
  * 需要的时间
* How much effort
  * 需要的工作量【直接关乎报价】
* How many people
  * 需要多少人投入
* Resources
  * 有哪些资源【硬件+软件】
* Risks
  * 评估风险【是否能在一定时间内交付】



#### **Empirical Estimation models**【经验估计模型】

* 一种估算技术

* COCOMO (COnstructive COst MOdel)

  <img src="C:\Users\all\AppData\Roaming\Typora\typora-user-images\image-20210619115349346.png" alt="image-20210619115349346" style="zoom: 67%;" />

  * E：effect
  * B：special skills factor特殊技能
  * P：productivity parameter提高生产力的参数
    * P:越小，工作量越大【如特斯拉：2000，通讯软件：10000，系统软件:28000】
  * t：project duration项目持续工期

* COCOMOII实际上是一个估计模型的层次结构，涉及以下领域
  * application composition model 应用程序组合模型
    * 在软件工程的早期阶段使用，当用户界面的原型化、考虑软件和系统交互、性能评估和技术成熟度评估时是最重要的
  * early design stage model 早期设计阶段的模型
    * 在需求并建立基本软件体系结构后使用
  * post-architecture-stage model 后体系结构阶段的模型
    * 在软件的构建过程中使用

#### **The** **Make-Buy** **Decision**

一般重用是第一选择，从长远看还是要build，由于企业利益可能合适外包或直接买

![image-20210619115926365](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619115926365.png)



### **Ch.34** **Project Scheduling**

#### **The** **Putnam-Norden-Rayleigh** **(PNR) Curve**

表明投入工作量和交付时间的关系

![image-20210619140659616](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619140659616.png)

* td：进度计划的交货时间
* to：理想的开发时间
* ta：实际交货时间
* Tmin=0.75td【最小时间】



#### timeline chart时间表

* 菱形代表评审【可以有微调，但不能拖得太长】

  ![image-20210619140857958](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619140857958.png)

#### **Effort Allocation/Distribution**【40-20-40 rule】

* **Front end** **activities**【前期分析与设计40-50%】

  * customer communication 10-25%

  * analysis

  * design 

  * review and modification 评审与纠错

    【后三项20-25%】

* **Construction activities**【构建活动15-20%】
  
  * coding or code generation 编码与整合
* **Testing and installation**【30-40%】
  * unit, integration
  * white-box, black-box
  * regression[回归测试，改了这个模式，可能其他模块受到影响]

 

#### Earned Value Analysis (EVA)  收益价值分析【挣值分析】

###### Earned Value

* 是项目进展的测量
* 采用定量的分析方法来评估项目的“完成百分比"【不要用直觉判断】
* 早在项目进展15%的时候就提供了精确且可靠的性能数据

###### 概念

* budgeted cost of work schedule（BCWS）计划的工作任务的预算
* budget at completion（BAC）完成工作的预算【是BCWS的和】
* budgeted cost of work performed (BCWP):已完成工作的预算
* actual cost of work performed(ACWP)：实际完成的工作成本

###### analysis

* schedule performance index:进度表执行指标 SPI=BCWP/BCWS

* schedule variance 进度表偏差  SV=BCWP-BCWS

* percent scheduled for completion=BCWS/BAC【预定完成百分比】

* percent complete=BCWP/BAC【实际完成百分比】

  

* cost performance index CPI=BCWP/ACWP【成本执行指标】

* cost variance CV=BCWP-ACWP【成本偏差】



### **Ch.35** **Risk Analysis**

#### **Reactive** **vs.** **Proactive** **Risk Strategies**

* 被动的 reactive risk management【项目团队在风险发生时做出反应】

  * 一般被称为fire-fighting mode【救火模式，比如加人】
    * 预期消防预期的额外资源计划
  * 修复错误
    * 在风险发生时发现的并应用的资源
  * 如果救火失败，则使用crisis management【危机管理】
    * 失败不响应应用的资源，项目处于危险

* 主动的proactive risk management

  * 要正式与形式化的分析，在技术工作开始之前启动，识别潜在风险，对风险【根据发生概率与重要性】进行排序，然后团队建立管理，回避大部分风险。

  * 找到根本的原因

    * statistical SQA根据统计的SQA
    * 有的时候风险原因在软件之外
    * 发展能够管理变革的技能

    

#### **Risk Identification**

可分为

* generic risk【一般风险】
* product-specific risk【产品特定风险，只有对特定的技术，人员环境非常了解的人才能识别】

风险条目表

* 产品规模
* 商业影响
* 项目相关人员特性
* 过程定义
* 开发环境
* 开发技术
* 人员才干和经验

风险因素

* performance risk性能风险
  * 产品能满足要求与使用目的的不确定程度
* cost risk 成本风险
  * 能维持项目预算的不确定程度
* support risk支持风险
  * 开发出的软件易于纠错，修改，升级的不确定程度
* schedule risk进度风险
  * 能维持项目进度的不确定程度

每个驱动程序对每个零部件的影响程度

* neglible 微不足道的
* marginal 轻微的
* critical 严重的
* catastrophic 灾难性的

![image-20210623202943911](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210623202943911.png)

#### **Risk** **projection**(**risk estimation)**

总体risk exposure，RE，使用以下关系确定【整体风险显露度】

* RE=P×C
* P：估算发生的概率
* C:产生的影响【严重为5，较轻为1】
* 结果RE要进行排序

#### Risk Mitigation,Monitoring, and Management (RMMM)

* mitigation：如何避免和减缓风险
* monitoring：防控监测，找原因会导致危险
* management：管理，应急计划，把最坏的考虑，有什么补救的方法

风险分析的八个步骤

![image-20210619143654030](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210619143654030.png)





### **Ch.36** **Maintenance and Reengineering**

#### **Software Reengineering**

![image-20210619144138849](C:\Users\all\AppData\Roaming\Typora\typora-user-images\image-20210619144138849.png)

从inventory analysis开始

* inventory Analysis

  * 生成一个包含所有应用程序的表
  * 建立一个标准的列表【包括应用名称，实际变更数等等】
  * 分析并确定优先级来选择重新设计的候选对象

* document restructuring

  * 全部重新构建文档太花时间，所以不用改的就算了
  * 文档必须更新，但人手有限，则就改接触到的文档，其他不改
  * 系统太烂的情况下，需要重新构建并削减文档

* reverse engineering【逆向工程？】

  <img src="C:\Users\all\AppData\Roaming\Typora\typora-user-images\image-20210619144702408.png" alt="image-20210619144702408" style="zoom:67%;" />

  * ​	

* code restructuring

  * 要用重组工具分析源代码

  * 如果太烂要重构
  * 违反结构化设计，则要重构
  * 重构后需要测试，避免异常
  * 文档也要相应重构

* data restructuring

  * 与抽象级别相对较低的代码重组不同，数据结构是一个全面的重新设计活动
  * 在大多数情况下，数据重组从反向工程活动开始【】
    * 详细分析了当前的数据体系结构（仔细分析），并定义了必要的数据模型
    * 识别数据对象和属性，并审查现有数据结构的质量。
    * —当数据结构较弱时（例如，当前实现了平面文件，当关系方法将大大简化处理时），数据将被重新设计。

  * 数据重构涉及到整个项目的重构
  * 不可避免地带来体系结构和代码地变更

* forward engineering

  * 维护一行代码可能比发展一行代码花费更多【20-40倍】
  * 可以利用现代的体系结构设计理念可以更好地维护
  * 原型已经存在，开发效率可以更加高
  * 由于用户对软件有经验了，新需求和新的变动方向很容易确定
  * CASE工具可以自动构成工作的一部分
  * 完全的软件配置【文档，程序与数据】在预防性维护后一直存在

#### **Economics of Reengineering**

* sneed提出了cost/benefit analysis model,9个参数

  * P1 = current annual maintenance cost for an application. 

    维护一年的价格

  * P2 = current annual operation cost for an application

    操作一年的价格

  * P3 = current annual business value of an application.

    一年的收益

  * P4 = predicted annual maintenance cost after reengineering. 

    预测重构后维护价格

  * P5 = predicted annual operations cost after reengineering

    预测重构后操作价格

  * P6 = predicted annual business value after reengineering

    预测重构后收益

  * P7 = estimated reengineering costs

    评估重构的价格

  * P8 = estimated reengineering calendar time

    评估重构的时间

  * P9 = reengineering risk factor (P9 = 1.0 is nominal（名义上的）). 

    重构的风险

  * 其中L = expected life of the system

    

* 相关计算量

  * 与持续维护候选应用程序（即不执行再造）相关的成本可以定义为
    * Cmaint=[P3-(P1+P2)]×L
  * 再造工程相关的成本
    * Creeng =[ P6 - (P4 + P5) ]x (L - P8) - (P7 x P9)
  * 再工程的总体效益
    * cost benefit = Creeng - Cmaint
