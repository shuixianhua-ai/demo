### Agile development 敏捷开发

* 2001年，Kent Beck and 16 other noted software developers提出

* 具体要点

  * 个人和交流要比过程与工具更重要
  * 可执行的软件要比综合性文件更重要
  * 与用户的合作比合同谈判更重要
  * 对变化的响应比遵循计划更重要

* ​	Agility含义

  * 对变化的有效（快速并且自适应）响应

  * 所有利益相关者的有效沟通

  * 让客户参与到团队中

  * 组织一个团队，以便控制所执行的工作

  * 可以快速，增量地交付软件

    ![image-20210604192119157](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210604192119157.png)

* Agile process

  * 由客户对于需要内容的描述（场景）驱动
  * 计划是短期的
  * 迭代开发软件，以建设活动为重点
  * 提供多个“软件增量”
  * 在更改发生的时候进行调整

* Agile priciple

  * 首要任务是提前和持续交付有价值的软件
  * 欢迎不断变化的需求【即使在开发后期】，敏捷流程利用变革来实现客户的竞争优势
  * 在更短的时间内，经常提供可工作的软件
  * 业务与开发者必须每天一起工作
  * 围绕着有动机的个人来进行项目，提供环境与支持，相信他们能完成任务
  * 面对面对话是向开发团队内部传达信息的最有效方式
  * 可工作的软件是衡量过程的主要标准
  * 敏捷开发促进了可持续发展
  * 持续关注卓越的技术水平和良好的设计，提高灵活度
  * 简单--最大化不用完成的量
  * 选择最佳的体系结构，需求以及设计
  * 团队定期反思如何更有效，并作出调整

* 人为因素【因为敏捷开发要符合人们和团队的需求，所以人员要具备一些特征】

  * 能力
  * 共同的关注点
  * 协作
  * 决策能力
  * 模糊解决问题的能力
  * 互信和尊重
  * 自我管理

  

  

  #### 常见的一些敏捷过程（Agile Process）模型

* **Extreme Programming(XP，最广泛使用的敏捷开发，Kent Beck提出)**

  * XP Planning

    * 从创建用户故事开始
    * 敏捷团队评估每个故事并分配成本
    * 将故事分组，以便获得可交付成果的增量
    * 给出关于交付时间的承诺
    * 在第一个增量之后，使用“项目速度”帮助定义其他增量的交货日期

  * XP Design

    * 遵循KIS（keep it simple原则）
    * 使用CRC卡
    * 对于困难的设计问题，建议创建spike解决方案【一个设计原型】
    * 鼓励“重构”【对于内部程序进行迭代细化】

  * XP Coding

    * 建议在编码开始之前为存储区域进行单元测试
    * 鼓励“配对编程”【pairing programming】

  * XP Testing

    * 每天都要执行所有的单元测试
    * “验收测试”由客户定义并执行，以评估可见功能

    ![image-20210604203544477](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210604203544477.png)

    ![image-20210604203723926](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210604203723926.png)
    
    

* **Industrial XP{IXP}**

  * IXP主要包括管理人员，扩展的客户角色和升级的技术实践

  * 主要整合了六种新实践

    * Readiness assessment【项目准备情况评估】
    * project communinty【项目社区】
    * project chartering【特许的，项目租赁工程？】：团队自主对项目进行检查
    * Test driven management：测试驱动管理？
    * retrospectives（回顾）：增量交付后的技术评估
    * continuous learning：持续学习
  
    
  
* **Scrum**[由Schwaber and Beedle提出]

  * 特征
    * 工作被划分成“包”
    * 在产品构建过程中，测试和文档是不间断的
    * 工作是在sprints【冲刺】的状态下进行的，并且动力来源于backlog【存在需求的待完成项】
    * 会议一般简短非正式
    * ‘‘demo“一般是按阶段交付的

  ​	

  ![image-20210605150636921](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210605150636921.png)

* **Dynamic Systems Development Method**【动态系统开发方式】

  * 由DSDM联盟推广【和XP很像，有九个指导原则】
  * 必须主动进行用户参与（必要的）。必须授权DSDM团队（授权）做出决策。重点是产品的频繁交付。适合于商业目的是接受可交付成果的基本标准。迭代和增量开发对于（聚集）收敛在一个精确的业务解决方案上是必要的。开发过程中的所有更改都是可逆的（可逆的）。要求在整个生命周期中集成了高级测试

  

  #### 
  
* Agile Modeling

  * Scott Ambler提出
  * 特点
    * 由计划来建模
    * 用多个模型
    * 轻装上阵---学会舍弃
    * 内容比表示更重要
    * 了解建模的模型与相应工具
    * 本地适应
  * ui

* Agile Unified Process（AUP）

  * 每次AUP迭代都涉及
    * modeling
    * implementation【实施】
    * testing
    * deployment
    * configuration and project mannagement【配置与项目管理】
    * environment management

  

* 敏捷：开发过程是被压缩的
  * 需求更改迅速
  * 开发者沟通迅速
*  与water model对比
  * 极限编程XP比较注重规程，产品，而scrum比较注重个人
  * 敏捷开发适合于小的项目，一般用于外包
  * k
* 一般敏捷开发都要频繁地开会，开会内容主要涉及
  * 做了什么
  * 有什么困难
  * 下次展示什么

 

 

###  软件人员【软件工程最重要的因素】

* 概念：
  * 在软件工程中，人对一个项目的成功引起的作用和那些最新最好的技术是一样的
  * 软件由人开发，被人使用并支持人与人之间的互动。所以人的特性，行为与合作是实际的软件开发重心

* 软件工程师的特质
  * 个人责任感
  * 对一些人的需求有敏锐的意识
  * 坦诚的（指出有问题的设计）
  * 抗压能力
  * 高度的公平感（避免利益冲突，不破坏他人劳动成果）
  * 注重细节（利用产品已有的概括性标准在日常工作基础上仔细思考，进而做出技术性决策）
  * 务实



* 软件工程心理学
  * Bill Curtis和Diane Walz提出分层的行为模型

 <img src="https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210617000556788.png" alt="image-20210617000556788" style="zoom:50%;" />

①在个人层面，软件工程心理学注重待解决的问题，解决问题需要的技能，以及解决问题的动机（在模型外层建立的限制内）

②在团队和项目层面，团队能动性为主要因素，成功是由团队结构和社会因素决定的。

③结合①②可得，团队交流和个体技能等同重要。

④在外部层面，有组织的行为控制着公司行为和对商业环境的应对方式



  * 个人包括：

    * 外联员ambassador：和外部顾客进行谈判，并得到利益相关者的反馈
    * 侦察员scout：收集组织信息（外部市场，新技术，外界相关活动，潜在对手的活动）
    * 守护员guard：保护团队工作产品和其他信息产品
    * 安检员sentry：把控利益相关者和他人向团队传送的消息
    * 协调员coordinator：注重跨团队以及组织内部的交流

  * 有效的软件团队属性

    * 目的感
    * 参与感
    * 信任感
    * 改进感（（定期审视软工方法并找改善））
    * 团队成员技能的多样性（多元性）

* 敏捷团队

  * 强调**个人能力**和**团队协作**作为关键成功因素
  * 人比过程重要，而politics【政治？】比人重要
  * 敏捷团队是自组织的，有很多结构
    * 一个自适应的团队结构
    * 使用Constantine的random，open，synchronous的结构
    * 显著的自主性
  * 计划保持在最低限度，并且仅受业务要求和组织标准的限制【比如scrum中的每日会议】
  * ​	

* 敏捷团队中的XP团队价值观？

  * 沟通（取消团队成员和利益相关者之间非正式沟通，建立隐喻【象征】作为持续反馈的一部分）
  * 简单（对于即时需求或未来需求设计）
  * 反馈（源于实施的软件，客户以及其他团队成员）
  * 勇气（面对团队成员和利益相关者之间的压力）
  * 尊重（团队成员和利益相关者）

* XP团队

  * 强调：客户与开发者密切（一般口头）合作，避免长文档，交流概念
  * 特点：团队强调当下需求而不是长远的。
  * 反馈：软件（通过测试结果）客户 其他软件团队成员

  

* ​	社交媒体的影响

  * 博客（可以共享用户与开发者的信息）
  * 微博（可以给个人实施发送信息）
  * targeted on-line forums[目标在线论坛]（允许参与者发布问题求助）
  * 社交网站（qq，允许开发人员的交流）
  * social book marking【社会书签标记？】允许开发人员跟踪共享基于web的资源【Delicious】
  * 公开一些信息是有害的，所以要在社交媒体的优点和私有信息不受控制的公开之间权衡

* ​	使用云的软件工程【云计算提供了一种获取各种软件工程工作产品，人工制品以及项目相关信息的机制】

  * 好处
    * 提供对所有软件工程产品的访问
    * 删除设备依赖性
    * 团队进行独立于平台，低风险的新型软件实验，得到反馈
    * 提供用于发布和测试软件的途径
    * 允许一个成员的信息提供给其他人
    * 沟通方便【管理，进度安排，任务列表，需求和缺陷管理这些功能可进行自我调整】
    * 影响软件工程师组织团队的方式，工作的方法，交流和连接的方式，管理项目的方式。
  * 缺陷
    * 分布在多个服务器，不受软件团队的控制
    * 可靠性与安全性问题，【云强调可用性与性能这个和安全性，可靠性等冲突】
    * 由于云上分布大量服务，互操作性问题可能性很高
  * ​	i

* collaboration(协作工具)【软件开发环境SDE--》协作开发环境CDE【collaboration development environment】】

  * 功能：实现简易化，自动化，对整个开发过程控制
  * 有价值的CDE会提供一系列服务
    * 命名空间（可选择性访问,允许安全，私有存储或工作产品的命名空间）
    * 进度表（协调会议，事件）
    * 模板（保持一致的外形和结构）
    * 度量支持（量化贡献）
    * 交流分析会（跟踪整个团队的交流并分离出模式）
    * 项目（加工品）集群显示工作产品依赖性【如github】
  * ​	o

* Global Software Development（GSD）全球软件开发

  * 影响因素

    * 问题复杂度

    * 结果不确定（工作相关的决策会对另外的项目产生意外的影响）

    * 对问题的不同看法才是导致不同结论的关键

    * 额外的挑战与协作的困难

      ![image-20210606142042723](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210606142042723.png)

      

  

### principles that Guide Practice【指导实践的原则】

* emm看ppt？

### **Project Management** **Concepts**【项目管理概念】

##### 管理范围：人--》产品--》过程--》项目（项目计划）

######  人：培养有动机，熟练的人

* CMM（capability maturity model）：决定了安置员工，交流，合作，工作环境，行为管理，训练，补偿，能力分析，发展，职业发展，团队发展，团队或文化发展。

* People-CMM maturity 高的组织可以更高效地实施项目

* the People-CMM是CMM的一个指标，可以引导组织创造一个成熟对的软件过程

* 人包括

  * 开发者：
    * 高级经理【决定重要问题】
    * 项目经理（高级工程师）【规划，动力，组织，控制开发者】
    * 开发者
    * 客户
    * 最终用户

  

  * 团队领导者【发挥人的最大技术和能力】

    * MOI model
      * M:Motivation,动机，激励开发者
      * O：Organization，利用现有成果，将现在的理论转化成最后成果
      * I：ideas/innovation，创新，激励人们去创新

    * 工作：理解问题，自由流动的想法，让所有人知道质量最重要
    * 四个特性：
      * 问题解决（可以确定关键的技术性的，组织性的问题）
      * 管理明确 （关于开发者的一些创新，需要取得控制）
      * 成就（学会奖励新方案/成就来优化项目组）
      * 影响和团队构建（学会理解人）

  * 团队

    * 最好的团队结构取决于管理风格，团队的人数以及人的技术水平以及问题的难度

    * 组件队伍必须考虑的因素
      * 问题难度 
      * 代码的规模，方法点
      * 团队合作的事件
      * 问题的可模块化程度
      * 系统的质量与可靠性
      * 截止日期
      * 项目的交流需求程度

    * 团队的组织范式【Constantine提出四种“组织模式”】
      * **closed paradigm** 传统的层级结构，传统权力层级，对于原来类型的软件较好，但创新性不高。【高级工程师（计划，协调，审查），技术人员，支持工程师，主程序员（可以有专家，支持人员，软件管理员支持）】
      
      * **random paradigm**松散地构建一个团队，并依赖于团队成员的个人主动性。适合创新型和技术性突破，但难完成有秩序的操作。最好是创新的无序，将创新活力运用于创建高效能团队
      
      * **open** **paradigm**兼具封闭的可控性又有随机的创新型，成员合作完成工作，有丰富的交流和达成共识的决定，适合解决复杂的问题，但没有其他团队效率高
      
      * **synchronous** **(同步的**)paradigm**依赖问题的划分，将队员分成不同组，彼此之间没什么沟通
      
        
      
    * 不利于团队的因素
      * 一种混乱的工作氛围，成员浪费精力，失去对目标的关注（应该有工作所需的所有信息，不轻易改变目标）
      
      * 由个人、商业，技术带来的高度挫折（尽可能对决定负责，通过了解产品和人员来选择过程模型，避免不当的软件过程）
      
      * 碎片化/不协调/模型选择不当导致实施困难
      
      * 对软件团队中角色的模糊定义（建立责任机制，还可以找到正确方式） 
      
      * 持续的反复接触失败，导致成员失去信心（这个是建立团队为基础的反馈和问题解决技巧）
      
        
      
    * 交流问题：工作者距离太远，不确定性，互操作性【现在软件特征】
    
      * 正式的交流方式包括工程文件，源代码，备忘录，时间表等
      * 正式的人际关系程序侧重质量保证活动，包括审查会议，代码检查等
      * 电子通信包括电子邮件，视频会议等
      * 利益相关网中包括非正式会议帮助解决项目

    * Agile Teams【敏捷团队】

      * 团队成员相互信任

      * 技能分配需要与问题相适应
    
      * 团队中没有害群之马
    
      * 团队是自我管理的
    
        * 有合适的团队结构
    
        * 用到自由/开放或者同步的范式
    
        * 自主权
    
          

###### 产品（产品目的）

* 作用：得到合理的花销，风险评估，分解工程任务，工程计划表（一般这个是软件工程的第一步）

* 产品目的：明确产品的所有目标

* 产品范围：明确产品的初始数据，方式，行为【范围必须要在管理与技术层面上明确】

  * context（环境）：软件如何适应更大的系统等，以及环境中的约束
  * information objectives(信息目标):用户可见数据，如何输出，输入
  * function and performance（方法与性能）：如何执行使得输入变成输出，是否需要解决任何特殊的性能特性

  

* 对问题的分解 problem decomposition【partitioning/problem elaboration】

  * 一旦产品目的和范围被确定，可供选择的解决方案就确定了，虽然有些小细节需要讨论，但可以让管理者们选择较好的方案，一般被交付期限，预算，个人能力，技术接口，等其他要素约束
  * 分解直至所有方法与问题被定义





###### 过程：

提供了一个框架（可以被度量的），少量的框架就可以应用于所有的项目，而其中，任务，里程碑，工作成果，质量保证点使得整个框架更加适合项目

* 流程框架的建立考虑点

  * 项目特点，使用产品的用户，以及开发者，产品本身的特点，团队工作环境

  * 严格程度【rigor required】

  * 对每个活动定义任务单【包括软工任务，可执行产品，测试点，里程碑】

    ![image-20210604095730441](https://raw.githubusercontent.com/shuixianhua-ai/demo/main/image/image-20210604095730441.png)

  * o

* 合并产品和过程（项目计划伴随着合并产品和过程）

* 过程分解（团队需要灵活地选择最好的模型），对于小的并且与之前类似的项目，建议采用线型方式

* 对于较小的，相关的程序，需要的任务

  * 说明清楚一系列问题
  * 和开发者说明以上问题
  * 共同得到陈述的范围
  * 会看陈述
  * 修改陈述

  

###### 项目

* 项目问题

  * 开发人员不了解客户需求，产品适用范围不当，变更管理很差，所选的技术会发生变化，ddl不现实，团队缺乏适当技能的人员等等

* 研究项目的常识性问题

  * 正确开始。要充分理解待解决的问题，再设立目标与期望
  * 保持动力。pr要提供鼓励，让人员流动保持到最低。提高质量。
  * 跟踪工作进度。一般生产产品和跟踪进度（正式的技术审核）是质量保证活动的一部分。
  * 进行事后分析。建立一个一致的机制来提取每个项目的经验教训

* 如何了解项目的本质（W5HH）

  * *W*hy is the system being developed?
  * *W*hat will be done? 
  * *W*hen will it be accomplished?
  * *W*ho is responsible?
  * *W*here are they organizationally located?
  * *H*ow will the job be done technically and managerially?
  * *H*ow much of each resource (e.g., people, software, tools, database) will be needed?

* critical practices关键性实践

  * Formal risk management（正式的风险管理）

  * Empirical cost and schedule estimation（经验成本与进度的估计）

  * Metrics-based project management（基于指标的项目管理）

  * Earned value tracking（收益价值跟踪）

  * Defect tracking against quality targets（对于质量目标缺陷的跟踪）

  * People aware project management（人们关注点的项目管理？）

    

* 实施安排好的，可控的项目的原因：这个是唯一的管理复杂的方式

* 现在软件失败率较高，为了防止这，所以管理者需要避免一些常见的错误，选择合适的方式去规划，执行，控制项目

⑤项目交流的需求

\9. 项目

90-90rule：最初的90%的系统承受90%的时间和精力



 

 

 

Living model：